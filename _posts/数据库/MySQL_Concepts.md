---
title: MySQL学习笔记-概念部分
author: Ping
math: true
date: 2023-05-27 14:33:00 +0800
categories: [数据库学习]
tags: [MySQL, 数据库]
---

## MySQL介绍

MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，属于Oracle旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB应用方面，MySQL是最好的RDBMS(Relational Database Management System，关系数据库管理系统)应用软件之一。在Linux上进行学习的是MySQL的开源版本MariaDB。

## 层次模型

**特征：**

- 有且只有一个结点且没有双亲结点，该结点称为根结点；
- 根结点以外的其他结点有且只有一个双亲结点；

## 网状模型

**特征：**

- 允许一个以上的结点无双亲；
- 一个结点也可以有多于一个双亲；

## 关系模型

**特征：** 可以理解为一张表(table)

**关系模型中的一些定义：**

- **关系：** 一个关系对应通常说的一张表；
- **元组：** 表中的一行；
  - **悬浮元组(Dangling tuple)：** 两个关系做自然连接时，其中一个元组有可能在另一个元组中不存在公共属性上值相等的元组，从而造成的被舍弃的元组。
- **属性：** 表中的一列；
- **码：** 也称码键，表中的某个属性组；
- **域：** 是一组具有相同数据类型的值的集合；
- **分量：** 元组中的一个属性；

### 关系模式

关系模式本质上是对关系的描述，关系即一张表，一张二维表；

关系中需要描述的部分：R(U, D, DOM, F)

- 关系中有哪些属性(U即为属性名，F为属性间的依赖关系)；
- 这些属性来自哪些域(D代表域)；
- 属性与域之间的映射关系(DOM代表映射关系)；

### 关系语言

- **关系代数语言**
  
  是一种抽象的查询语言，它用对关系的运算来表达查询，有三大要素：
  
  - **运算对象(关系)**
  - **运算符(包括集合运算符和专门的关系运算符)**
    - **集合运算符：**并$\cup$、差$\setminus$、交$\cap$、笛卡尔积$\times$(并不会发生数据的乘除计算)；
    - **关系运算符**
      - 选择$\sigma$(基于一定条件选择，选择行)；
      - 投影$\pi$(选择所要求的列)；
      - 连接$\Join$：又分为自然连接(共同属性等值连接)、外连接、左外连接、右外连接；
      - 除$\div$；
  - **运算结果(关系)**

- **关系演算语言**
  
  (暂略)

- **SQL语言**
  
  在以下的[操作部分](## 操作部分)有详细的笔记；

## MySQL数据类型介绍

为了对数据库进行设计，熟练掌握数据类型是很必要的一个环节；

### 字符串类型

- **CHAR**

  固定长度字符串；

- **VARCHAR**

  可编入索引，可变长度字符串，最大大小64KB，最多字符个数65535，超过这个部分将会被截断；

- **MEDIUMTEXT**

  可变字符长，最大大小16MB；

- **LONGTEXT**

  可变字符长，最大大小4GB；

- **TINYTEXT**

  可变字符长，最大大小255 bytes；

以上所有类型都支持国际字符，英语每个字母占一字节，中东语言占二字节，中文和日文占三字节；因此在分配字符串长度之时，会自动分配乘以字节数之后的空间；

### 整数类型

- **TINYINT：**1B
- **UNSIGNED TINYINT：**1B，[0, 255]
- **SMALLINT：**2B
- **MEDIUMINT：**3B
- **INT：**4B
- **BIGINT：**8B

INT(4)==>0001，这是一种存储方式，代表4位长度的整数；

尽量用符合实际的长度去存储信息，节约空间以及提升效率；

### 定点数类型和浮点数类型

- **DECIMAL(p, s)：**定点数，比如DECIMAL(9, 2) => 1234567.89
- **DEC、NUMERIC、FIXED：**同上类型
- **FLOAT：**4B，单精度浮点数
- **DOUBLE：**8B，双精度浮点数

### 布尔类型

判定真假的类型：`BOOL`、`BOOLEAN`；

### 枚举和集合类型

- **ENUM(..,..,....)：**枚举类型应用于某列中仅支持固定类型值的情况，有一个缺陷就是不好拓展，新增或减少一部分枚举内容需要对整张表进行重建；
- **SET(...)：**表格内容允许多个值的存储；

### 日期和时间类型

- `DATE`-存储没有时间成分的日期；
- `TIME`-存储一个时间；
- `DATETIME`-存储日期和时间；
- `TIMESTAMP`-时间戳，只能存储到2038年以前的日期时间；
- `YEAR`-年份；

### Blob类型

存储大型二进制数据；

- `TINYBLOB`-255B
- `BLOB`-65KB
- `MEDIUMBLOB`-16MB
- `LONGBLOB`-4GB

不建议用数据库存储二进制数据，因为关系型数据库是为了处理结构化关系型数据设计的；存储在数据库中，数据库大小会迅速提升，且性能会受较大影响；

### JSON类型

JSON类型的文档是一种通过网络存储和传输数据的轻量级文件格式；应用程序通过JSON将数据发送到后端；

```json
{
    "key": value
}
```

在SQL中添加json配置：

```sql
USE sql_store;
UPDATE products 
SET properties = '{
 	"dimensions": [1, 2, 3],
 	"weight": 10,
 	"manufacturer": {"name": "sony" }
 }'
 WHERE product_id = 1;
 -- 或者
 SET properties = JSON_OBJECT(
	'weight', 10,
	'dimensions', JSON_ARRAY(1, 2, 3),
	'manufacturer', JSON_OBJECT('name', 'sony')
)
-- 更改JSON内容
SET properties = JSON_SET(
	properties,
	'$.weight', 20,	-- 有key的则更改
	'$.age', 10		-- 没有key则新增项
)
-- 移除
SET properties = JSON_REMOVE(
	properties,
	'$.age'		-- 删除age的key
)
```

## MySQL属性介绍

### 列属性(Column Attributes)

这部分结合图表来进行学习：

<img src="/assets/img/SQL/列属性.png" alt="image-20230317164552473" style="zoom:50%;" />

- **列名(Column)**-每一列详细的名字信息；
- **数据类型(Datatype)**-每一列数据中的数据类型：
  - `INT`-代表整型数字；
  - `VARCHAR(50)`-代表可变长度的Char类型，最长50位，与之对应的是`CHAR`类型，如果没有满足相应长度，会填满那个长度；
  - `DATE`-日期的数据格式；
- **主键PK(Primary Keys)**-是<font color=red>表格中的唯一标识给定表中每条记录的列</font>，以图表中数据为例，customer_id即为主键；
- **NN(Not NULL)**-该列是否可以写空值，像上表中customer_id、first_name、last_name就不能写空值；
- **AL(Auto-Increment)**-一般用在主键列，当新增一条记录的时候，该主键列会递增；
- **Default/Expression**-标明了每列的默认值；


## 数据库设计

### 数据建模(Data Modeling)

在Mosh看来，良好的数据库建模需要遵照以下几个步骤：

- **理解需求**

  充分了解自己的业务需求，查询现有的资料，收集充分信息；

- **构建概念模型**

  识别业务中的实体、事物或概念以及它们之间的关系；概念模型只是我们所用概念的一种视觉表示，用于相互之间的交流；

- **建立逻辑模型**

  当模型构建完毕，我们需要生成一个数据模型或数据结构用以存储数据；逻辑模型是独立于数据技术的抽象数据模型，它只显式需要的表和列；

- **建立物理模型**

  为特定的数据库管理系统构建一个实体模型，这个实体模型是围绕数据库技术的逻辑模型的实现；

以下是针对各个模型的介绍：

#### 概念模型(Conceptual Models)

以建立一个销售在线课程的网站为例：

- 用户注册一个或者多个课程；
- 一个课程可以有一个或多个标签；

针对这个例子，我们首先开始建立一个概念模型：这当中有至少两个实体：学生和课程；建立一种可视化方法以表示他们之间的联系；

可视化方法通常有：

- ER图(Entity Relationship)；
  - Visio，draw.io网站；
- UML图(标准建模语言)；

#### 逻辑模型(Logic Models)

逻辑模型是一个抽象的数据类型，能清楚的显示我们的实体以及关系架构，且独立于数据库技术之外，我理解为<font color=red>我们人类大脑思考的方式</font>；

同样基于上述的例子，在两个实体当中：

- 学生，他的属性是什么，每个属性的类型又是什么样的，是字符串？还是数字类型，等等？
- 课程，他的属性又是什么，每个属性的类型又是什么样的，是字符串还是数字类型？

在对上述两个实体完成逻辑上的抽象之后，我们需要接着思考，他们之间的关系又是怎么样的呢？多对多，还是一对多，还是多对一.....

这样就够了吗？

涉及到课程的注册，那么势必会有一个注册时间，注册时间上来说，如果把该属性放入学生这个实体，一个学生又可以在不同的时间上去注册课程，所以这个属性不是单一的，如果将该属性放入课程这个实体，同一门课程又会有不同的被注册时间，因此，该属性需要单独安排一个实体；

即注册信息，这么一个实体，该实体不但可由注册时间，还能有注册时价格(不同的时间存在不同的价格)

#### 实体(物理)模型(Physical Models)

实体模型是逻辑模型通过特定数据库的实现。

在MySQL Workbench的实现中，相关的步骤是：

- "文件"选项卡新建"模型"，会生成EER(Enhance Entity Relationship)图等模板；
  - EER可以帮助我们识别问题，并允许我们对设计进行任何可能的更改

- 给模型命名，即上述提及到的实体模型；
- 通过模型的EER图去创建表和视图，自己根据实际情况去命名图表；
  - 实体模型是单数，但表是诸多学生的集合，因此复数；
- 考虑每一个学生，在逻辑模型部分，我们看到了学生的那些属性，这些属性我们作为学生那张表格的列；
  - 为这些列(属性)设置类型(CAHR, INT等)，通过MySQL这么一个数据库实体化逻辑模型；
- 设置其他实体，注意，这里的实体说的是<font color=red>概念模型中的实体</font>，而不是<font color=red>实体模型中的实体</font>；

### 确定主键(Primary Keys)

我们需要在实体模型部分确定的列中选出合适的列来唯一标识给定记录，根据实际情况考虑选择哪一属性；

- 主键应该能唯一标识；
- 主键的值不应太长，那样对存储空间不够优化；
- 理想情况下主键的值不会被更改，其他列的值(内容)是可以被修改的；

以上情形，如果已有主键都不好满足，那我们可以考虑新建一列，作唯一标识；主键不但值不会被更改，而且一定非空(NN)，毕竟是唯一标识；

MySQL中可以为主键标识*自动递增*；

同时可以设定复合主键，即在两列同时勾选PK；

### 外键(Foreign Keys)

当我们在添加关系时，关系的一端成为父表或主键表，另一端则是子表或外键表；

所谓外键，就是在外键表中引用了另一张表主键的那列；

而针对外键表，我们仍然需要选出<font color=red>主键</font>，这个过程需要根据实际情况按照上面的步骤来考虑；

#### 外键约束(Foreign Key Constraints)

为外键设置约束，本质上可以保护你的数据不受损坏；

在MySQL Workbench中，设置外键约束的方式主要是通过Foreign Key标签页来实现：

- 在==删除==的时候，外键怎么处理？

  - `RESTRICT`-限制，该选项会拒绝删除；

  - `CASCADE`-级联，主键更改，MySQL会同步删除<font color=red>子表</font>中的记录；
  - `SET NULL`-设为空值，如果ID变了就设置为空值，会导致子表失去了父表，一般不选；
  - `NO ACTION`-无操作，和`RESTRICT`几乎一致；

- 在信息==更新==的时候，外键又怎么处理？、

  - `RESTRICT`-限制，该选项会拒绝更新；
  - `CASCADE`-级联，主键更改，MySQL会自动更新<font color=red>子表</font>中的记录；
  - `SET NULL`-设为空值，如果ID变了就设置为空值，会导致子表失去了父表，一般不选；
  - `NO ACTION`-无操作，和`RESTRICT`几乎一致；

以上的处理是针对其他表格主键发生变化时的处理措施，即便一般而言我们不该更改主键；

### 标准化(Normalization)

标准化审查我们的设计，并确保它遵循一些防止数据重复的预定义规则的这一过程；

有七条规则，我们称之为七范式，每条规则都假设我们已经采用了前面几条规则；

对于99%的场景，我们只需要应用前三条范式；

#### 第一范式(1NF-1st Normal Form)

一行中的每个单元格都应该有单一值，且不能出现重复列；

有时我们无法保证每个单元格都是单一值，比如课程的标签(<编程>，<数据结构>，...)，这个时候如果为标签设计多列，是一个方案，但无拓展性；因此可以考虑为标签再增加一个实体，以满足第一范式；

#### 链接表(Link Tables)

**关系型数据库中并不存在多对多的关系**，因此我们需要新增一张链接表，以便在逻辑上实现多对多的关系；

其次，通过链接表，当我们需要改动标签的时候，我们不需要同时更新多行，我们只需要更新标签表(链接表)中的某一条记录即可；

(本质上是<font color=red>本质上是一对多，多对一，多对多三种关系的理解</font>)

#### 第二范式(2NF)

每张表首先都要符合第一范式，其次都应该有一个单一的目的，即它应该只能代表一种且仅有一种实体类型，表中的每一列都应该用来描述那个实体；

如果有一列描述了其他的东西，我们应该拿掉它，并放入一张单独表；

- 如果我们把一个不属于该表的属性放进去，那么当他需要更改的时候，我们得更新好几行的信息，显然不是一个好的做法；

- 以上的情形还可以拓展到很多方面，比如，属性本身并不是很明确他到底属不属于该表；

#### 第三范式(3NF)

每张表都要先符合第二范式，其次，第三范式表示，表中的列不得派生自其他列；

- 因为在更新数据时，更新了某列的值，这个派生的列不一定会同步更新；

### 模型的正向工程(Forward Engineer)

本质上是把模型转化成真实的物理数据库的过程：

- 在MySQL Workbench中找到Forward Engineer选项卡；
- 设定参数以连接数据库管理系统(用户名啊，密码啊，等等，一般为默认)；
- 在选项页(Options)设置要生成的脚本的选项(一般为默认)；
- 选择要编写脚本的对象类型；
  - 本例中只在实体模型中创建了表，因此选择Table Objects；
  - 如果有必要，可以选择过滤器，从编写对象中排除一张或多张表；
- SQL会生成脚本；
- 最终生成我们的表格；

#### 数据库同步模型(Synchronizing Model)

实际工作环境中，我们在不同环境里的数据库需要具有一致性，而不像我们私人使用的数据库，哪里缺一点可以自行增加，生产环境中我们需要处理好同步问题；

假设我们要在某个实体中新增一列，先回到EER图中增加这一列：

- 在MySQL Workbench中找到Synchronizing Model选项卡；
- 界面与Forward Engineer界面比较相似；
- 由于需要更新表，MySQL会暂时消除各表之间的关系，在修改完成之后，我们又会重新启用；

### 模型的逆向工程(Reverse Engineering)

有些表格并不存在像我们之前设计的<font color=red>学生注册课程</font>一类的模型，此时我们就需要为这个数据库进行反向工程，来创建一个模型，然后将该模型用于任何未来更改；

- 在MySQL Workbench中找到Reverse Engineer选项卡；
- 选择我们想包含进去的数据库(比如sql_store)；

### 总结

学习了数据库所有标准化的流程，但是实际项目应用中要结合业务需求去做决定，不要盲目套用标准化的流程；

一般而言，如果看到某列中存在着多个重复的数据，那么大概率数据库的设计没有符合标准化；

不要对什么都建模！要考虑实际业务需求，只需要为现下问题制定最佳解决方案就行；

## 数据库优化

### 使用高性能索引

在大型数据库和高流量网站中，索引非常重要，因为他们可以显著提高查询的性能；

索引本质上是数据库引擎用来快速查找数据的数据结构；

- 比如我们要查询某一列的数据，以state为例：
  - NY、CA、VA、CA四个地方，按正常来说应该是依次查找，在小型数据库无所谓；
  - 在大型数据库中，我们可以跟使用字典一样给各个地点排序，使用引用的方式，这样就能更快速定位到我们需要的记录；

索引的优势：

- 帮助我们快速找到数据，我们只需要将索引表放入内存即可，显著提升查找速度；

索引的劣势：

- 增加数据库的大小，因为他们必须永久存储在表旁边；
- 每次更新、添加、删除记录时，MySQL必须更新对应的索引，影响正常操作的性能；

因此我们**为性能关键的查询保留索引**；

使用索引的准则：

- 不应该基于表来创建索引，而是基于查询创建索引(索引就是为了加快查询)；

索引内部存储为**二进制树**；

- **索引创建**

  通过SQL语言创建索引：