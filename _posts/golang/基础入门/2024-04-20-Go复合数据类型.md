---
title: Go的复合数据类型
author: Ping
math: true
date: 2024-04-20 11:08:00 +0800
categories: [Go, 语言学习]
tags: [Go]
---

之前讨论了Go程序中的基础数据类型；它们就像宇宙中的原子一样。这部分介绍复合数据类型，复合数据类型是由基本数据类型以各种方式组合而构成的，就像分子由原子构成一样。接下来将重点讲解四种复合数据类型，分别是数组、`slice`、`map`和结构体。

另外末尾部分将演示如何将使用这些数据类型构成的结构化数据编码为JSON数据，从JSON数据转换为结构化数据，以及从模板生成HTML页面。

数组和结构体都是聚合类型，它们的值由内存中的一组变量构成。数组的元素具有相同的类型，而结构体中的元素数据类型则可以不同。数组和结构体的长度都是固定的。反之，`slice`和`map`都是动态数据结构，它们的长度在元素添加到结构中时可以动态增长。

## 数组

数组是具有**固定长度**且拥有零个或者多个相同数据类型元素的序列。由于数组的长度固定，所以在Go里面很少直接使用。`slice`的长度可以增长和缩短，在很多场合下使用得更多。然而，在理解`slice`之前，我们必须先理解数组。

数组中的每个元素是通过索引来访问的，索引从0到数组长度减1。Go内置的函数`len`可以返回数组中的元素个数。
```go
var a [3]int        // 3个整数的数组
fmt.Println(a[0])   // 输出数组的第一个元素
fmt.Print1n(a[len(a)-1])    // 输出数组的最后一个元素，即[2]
// 输出索引和元素
for i,v := range a {
    fmt.Printf("%d %d\n", i, v)
}
// 仅输出元素
for _,v := range a {
    fmt.Printf("%d\n", v)
}
```
默认情况下，一个新数组中的元素初始值为元素类型的零值，对于数字来说，就是0。也可以使用数组字面量根据一组值来初始化一个数组。
```go
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}
fmt.Println(r[2])   // 只有前两位初始化了，未被显式初始化的执行隐式初始化，初始化为"0"
```
在数组字面量中，如果省略号`...`出现在数组长度的位置，那么数组的长度由初始化数组的元素个数决定。以上数组q的定义可以简化为：
```go
q := [..]int{1,2,3}
fmt.Printf("%T\n", q)   // "[3]int"
```
数组的长度是数组类型的一部分，所以`[3]int`和`[4]int`是两种不同的数组类型。数组的长度必须是常量表达式，也就是说，这个表达式的值在程序编译时就可以确定。
```go
q := [3]int{1, 2, 3}
q := [4]int{1, 2, 3, 4} // 编译错误，q已经是一个长度为3的整型数组
```
如我们所见，数组、`slice`、`map`和结构体的字面语法都是相似的。上面的例子是按顺序给出一组值；也可以像这样给出一组值，这一组值同样具有索引和索引对应的值：
```go
type Currency int
const (
    USD Currency = iota
    EUR
    GBP
    RMB
)
symbol := [...]string{USD: "$", EUR: "E", GBP: "E", RMB: "￥"}   // 这里应该是map结构吧，学习到这里的时候是猜测
fmt.Println(RMB,symbol[RMB])    // "3 ￥"
```
在这种情况下，索引可以按照任意顺序出现，并且有的时候还可以省略。和上面一样，没有指定值的索引位置的元素默认被赋予数组元素类型的零值。例如，
```go
r := [...]int{99 : -1}  // 其实就是数组结构，只不过下标表现的形式改变了，这里表示下标99对应的元素为-1
```
定义了一个拥有100个元素的数组`r`，除了最后一个元素值是-1外，该数组中的其他元素值都是0。

如果一个数组的元素类型是可比较的，那么这个数组也是可比较的，这样我们就可以直接使用`==`操作符来比较两个数组，比较的结果是两边元素的值是否完全相同。使用`!=`来比较两个数组是否不同。
```go
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b,a == c, b == c)  // "true false false"
d := [3]int{1, 2}
fmt.Print1n(a == d) // 编译错误：无法比较[2]int == [3]int
```
举一个更有意义的例子，`crypto/sha256`包里面的函数`Sum256`用来为存储在任意字节`slice`中的消息使用SHA256加密散列算法生成一个摘要。摘要信息是256位，即`[32]byte`。如果两个摘要信息相同，那么**很有可能**这两条原始消息就是相同的；如果这两个摘要信息不同，那么这两条原始消息就是不同的。下面的程序输出并比较了`x`和`X`的SHA256散列值：
```go
import "crypto/sha256"

func main() {
    c1 := sha256.Sum256([]byte("x"))
    c2 := sha256.Sum256([]byte("X"))
    fmt.Printf("%x\n%x\n%t\n%T\n", c1, c2, c1 == c2, c1)
// Output:
// 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881
// 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015
// false
// [32]uint8
}
```
原始消息仅有1位(bit)之差，但是它们生成的摘要消息将近一半的位不同，`%x`表示将一个数组或者`slice`里面的字节按照十六进制的方式输出，`%t`表示输出一个布尔值，`%T`表示输出一个值的类型。

当调用一个函数的时候，每个传入的参数都会创建一个副本，然后赋值给对应的函数变量，所以函数接受的是一个副本，而不是原始的参数。使用这种方式传递大的数组会变得很低效，并且在函数内部对数组的任何修改都仅影响副本，而不是原始数组。这种情况下，Go把**数组和其他的类型都看成值传递**。而在其他的语言中，数组是隐式地使用引用传递。

当然，也可以显式地传递一个数组的指针给函数，这样在函数内部对数组的任何修改都会反映到原始数组上面。下面的程序演示如何将一个数组`[32]byte`的元素清零：
```go
func zero(ptr *[32]byte) {
    for i := range ptr {
        ptr[i] = 0
    }
}
```
数组字面量`[32]byte{}`可以生成一个拥有32个字节元素的数组。数组中每个元素的值都是字节类型的零值，即0。可以利用这一点来写另一个版本的数组清零程序：
```go
func zero(ptr *[32]byte) {
    *ptr = [32]byte{}
}
```
使用数组指针是高效的，同时允许被调函数修改调用方数组中的元素，但是因为数组长度是固定的，所以数组本身是不可变的。例如上面的`zero`函数不能接受一个`[16]byte`这样的数组指针，同样，也无法为数组添加或者删除元素。由于数组的长度不可变的特性，除了在特殊的情况下之外，我们很少使用数组。上面关于SHA256的例子中，摘要的结果拥有固定的长度，我们可以使用数组作为函数参数或结果，但是更多的情况下，我们使用`slice`。

## slice

`slice`表示一个拥有相同类型元素的可变长度的序列。`slice`通常写成`[]T`，其中元素的类型都是`T`；它看上去像没有长度的数组类型。

数组和`slice`是紧密关联的。`slice`是一种轻量级的数据结构，可以用来访问数组的部分或者全部的元素，而这个数组称为`slice`的底层数组。`slice`有三个属性：指针、长度和容量。指针指向数组的第一个可以从`slice`中访问的元素，这个元素**并不一定是数组的第一个元素**。长度是指`slice`中的元素个数，它不能超过`slice`的容量。容量的大小通常是从`slice`的起始元素到底层数组的最后一个元素间元素的个数。Go的内置函数`len`和`cap`用来返回`slice`的长度和容量。
- 有点像`vector`；

一个底层数组可以对应多个`slice`，这些`slice`可以引用数组的任何位置，彼此之间的元素还可以重叠。来一个数组声明：
```go
months := [...]string{1: "January", /*...*/, 12: "December"}
```
在这个数组里，January就是`months[1]`，December是`months[12]`。一般来讲，数组中索引0的位置存放数组的第一个元素，但是由于月份总是从1开始，因此我们可以不设置索引为0的元素，这样它的值就是空字符串。

`slice`操作符`s[i:j]`(其中`0 ≤ i ≤ j ≤ cap(s)`)创建了一个新的`slice`，这个新的`slice`引用了序列s中从i到j-1索引位置的所有元素，这里的s既可以是数组或者指向数组的指针，也可以是`slice`。新`slice`的元素个数是`j -i `个。如果上面的表达式中省略了i,那么新`slice`的起始索引位置就是0，即`i = 0`；如果省略了j，那么新`slice`的结束索引位置`1en(s) - 1`，即`j = len(s)`。因此slice对象`months[1:13]`引用了所有的有效月份，同样的写法可以是`months[1:]`。
- 注意：仍然是常规的`[ )`形式，可以理解为一个约定俗称的规则；

slice对象`months[:]`引用了整个数组。接下来，我们定义元素重叠的`slice`，分别用来表示第二季度的月份和北半球的夏季月份：
```go
Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2)     // ["April""May""June"]
fmt.Println(summer) // ["June""July""August"]
```
元素`June`同时包含在两个`slice`中。用下面的代码来输出两个`slice`的共同元素(虽然效率不高)，
```go
    for _, s := range summer {
        for _, q := range Q2 {
            if s ==q {
                fmt.Printf("%s appears in both\n", s)
            }
        }
    }
```
如果`slice`的引用超过了被引用对象的容量，即`cap(s)`，那么会导致程序宕机；但是如果`slice`的引用超出了被引用对象的长度，即`len(s)`，那么最终`slice`会比原`slice`长：
```go
fmt.Println(summer[:20])    // 宕机：超过了被引用对象的边界
endlessSummer := summer[:5] // 在slice容量范围内扩展了s1ice
fmt.Println(endlessSummer)  // "[June July August September October]"
```
另外，注意求字符串(`string`)子串操作和对字节slice(`[]byte`)做slice操作这两者的相似性。它们都写作`x[m:n]`，并且都返回原始字节的一个子序列，同时它们的底层引用方式也是相同的，所以两个操作都消耗常量时间。区别在于：如果x是字符串，那么`x[m:n]`返回的是一个字符串；如果x是字节`slice`，那么返回的结果是字节`slice`。

因为`slice`包含了指向数组元素的指针，所以将一个`slice`传递给函数的时候，可以在函数内部修改底层数组的元素。换言之，创建一个数组的`slice`等于为数组创建了一个别名(见2.3.2节)。下面的函数`reverse`就地反转了整型`slice`中的元素，它适用于任意长度的整型`slice`：
```go
//就地反转一个整型slice中的元素
func reverse(s []int) {
    for i,j := 0, len(s) - 1; 1 < j; i, j = i + 1, j - 1 {
        s[i], s[j] = s[j], s[i] // 交换
    }
}
```
这里，反转整个数组a:
```go
a := [...]int{0, 1, 2, 3, 4, 5}
reverse(a[:])
fmt.Println(a)  // "[5 4 3 2 1 0]"
```
将一个`slice`左移n个元素的简单方法是连续调用`reverse`函数三次。第一次反转前n个元素，第二次反转剩下的元素，最后对整个`slice`再做一次反转(如果将元素右移n个元素，那么先做第三次调用)。
```go
s := []int{0, 1, 2, 3, 4, 5}
// 向左移动两个元素
reverse(s[:2])
reverse(s[2:])
reverse(s)
fmt.Print1n(s)  // "[2 3 4 5 0 1]"
```
注意初始化slice s的表达式和初始化数组a的表达式的区别。`slice`字面量看上去和数组字面量很像，都是用逗号分隔并用花括号括起来的一个元素序列，但是`slice`没有指定长度。这种隐式区别的结果分别是创建有固定长度的数组和创建指向数组的`slice`。和数组一样，`slice`也按照顺序指定元素，也可以通过索引来指定元素，或者两者结合。

和数组不同的是，`slice`无法做比较，因此不能用`==`来测试两个`slice`是否拥有相同的元素。标准库里面提供了高度优化的函数`bytes.Equal`来比较两个字节slice(`[]byte`)。但是对于其他类型的`slice`，我们必须自己写函数来比较。
```go
// 仔细一看，实现逻辑其实极其严格
func equal(x, y []string) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}
```
这种深度比较看上去很简单，并且运行的时候并不比字符串数组使用`==`做比较多耗费时间。你或许奇怪为什么`slice`比较不可以直接使用`==`操作符做比较。这里有两个原因。首先，和数组元素不同，`slice`的元素是非直接的，有可能`slice`可以包含它自身。虽然有办法处理这种特殊的情况，但是没有一种方法是简单、高效、直观的。

其次，因为`slice`的元素不是直接的，所以如果底层数组元素改变，同一个`slice`在不同的时间会拥有不同的元素。由于散列表（例如Go的`map`类型）仅对元素的键做浅拷贝，这就要求散列表里面键在散列表的整个生命周期内必须保持不变。因为`slice`需要深度比较，所以就不能用`slice`作为`map`的键。对于引用类型，例如指针和通道，操作符`==`检查的是引用相等性，即它们是否指向相同的元素。如果有一个相似的`slice`相等性比较功能，它或许会比较有用，也能解决`slice`作为`map`键的问题，但是如果操作符`==`对`slice`和数组的行为不一致，会带来困扰。所以最安全的方法就是不允许直接比较`slice`。

`slice`唯一允许的比较操作是和`nil`做比较，例如：
```go
if summer == nil { /* ... */ }
```
`slice`类型的零值是`nil`。值为`nil`的`slice`没有对应的底层数组。值为`nil`的`slice`长度和容量都是零，但是也有非`nil`的`slice`长度和容量是零，例如`[]int()`或`make([]int, 3)[3:]`。对于任何类型，如果它们的值可以是`nil`，那么这个类型的`nil`值可以使用一种转换表达式，例如`[]int(nil)`。
```go
var s []int     // len(s) == 0, s == nil
s = nil         // len(s) == 0, s == nil
s = []int(nil)  // len(s) == 0, s == nil
s = []int{}     // len(s) == 0, s == nil
```

所以，如果想检查一个`slice`是否是空，那么使用`len(s) == 0`，而不是`s == ni1`，因为`s ！= nil`的情况下，`slice`也有可能是空。除了可以和`nil`做比较之外，值为`nil`的`slice`表现和其他长度为零的`slice`一样。例如，`reverse`函数调用`reverse(nil)`也是安全的。除非文档上面写明了与此相反，否则无论值是否为`nil`，Go的函数都应该以相同的方式对待所有长度为零的`slice`。

内置函数`make`可以创建一个具有指定元素类型、长度和容量的`slice`。其中容量参数可以省略，在这种情况下，`slice`的长度和容量相等。
```go
make([]T, len)
make([]T, len, cap) // 和make([]T, cap)[:len]功能相同
```
深入研究下，其实`make`创建了一个**无名数组**并返回了它的一个`slice`；这个数组仅可以通过这个`slice`来访问。在上面的第一行代码中，所返回的`slice`引用了整个数组。在第二行代码中，slice只引用了数组的前`len`个元素，但是它的容量是数组的长度，这为未来的`slice`元素留出空间。

### append函数

内置函数`append`用来将元素追加到`slice`的后面。
```go
var _, r := range "Hello, 世界" {
    runes = append(runes, r)
}
fmt.Printf("%q\n", runes)
```
看一下简易的实现：
```go
func appendInt(x []int, y int) []int {
    var z []int
    zlen := len(x) + 1
    if zlen <= cap(x) {
        // slice仍然有增长空间，那么可以就地拓展
        z = x[:zlen]
    } else {
        // 如果slice没有了增长空间，那么需要分配一个新的底层数组，一般而言，容量翻倍
        zcap := zlen
        if zcap < 2 * len(x) {
            zcap = 2 * len(x)
        }
        z = make([]int, zlen, zcap)
        copy(z, x)  // 内置copy函数，把x的内容给z
    }
    z[len(x)] = y
    return z
}
```
内置的`append`函数使用了比这里的`appendInt`更复杂的增长策略。通常情况下，我们并不清楚一次`append`调用会不会导致一次新的内存分配，所以我们不能假设原始的`slice`和调用`append`后的结果`slice`指向同一个底层数组，也无法证明它们就指向不同的底层数组。同样，我们也无法假设旧`slice`上对元素的操作会或者不会影响新的`slice`元素。所以，通常我们将`append`的调用结果再次赋值给传入`append`函数的`slice`:
```go
runes append(runes, r)
```
不仅仅是在调用`append`函数的情况下需要更新`slice`变量。另外，对于任何函数，只要有可能改变`slice`的长度或者容量，抑或是使得`slice`指向不同的底层数组，都需要更新`slice`变量。为了正确地使用`slice`，必须记住，虽然底层数组的元素是间接引用的，但是`slice`的指针、长度和容量不是。要更新一个`slice`的指针，长度或容量必须使用如上所示的显式赋值。从这个角度看，`slice`并不是纯引用类型，而是像下面这种聚合类型：
```go
type IntSlice struct {
    ptr *int
    len, cap int
}
```
`appendInt`函数只能给`slice`添加一个元素，但是内置的`append`函数可以同时给`slice`添加多个元素，甚至添加另一个`slice`里的所有元素。
```go
var x []int
x = append(x, 1)
x = append(x, 2, 3)
x = append(x, 4, 5, 6)
x = append(x, x...) // 追加x中的所有元素
fmt.Println(x)      // "[1 2 3 4 5 6 1 2 3 4 5 6]"
```
可以简单修改一下`appendInt`函数来匹配`append`的功能。函数`appendInt`参数声明中的省略号`...`表示该函数可以接受**可变长度参数列表**。上面例子中`append`函数的参数后面的省略号表示如何将一个`slice`转换为参数列表。后续会详细解释这种机制。
```go
func appendInt(x []int, y ...int) []int {
    var z []int
    zlen := len(x) + len(y)
    // ...扩展slice z的长度至少到z1en...
    copy(z[len(x):], y)
    return z
}
```
扩展`slice z`底层数组的逻辑和上面一样，所以就不重复了。

### slice就地修改

我们多看一些就地使用`slice`的例子，比如`rotate`和`reverse`这种可以就地修改`slice`元素的函数。下面的函数`nonempty`可以从给定的一个字符串列表中去除空字符串并返回一个新的`slice`。

```go
func noempty(strings []string) []string {
    i := 0
    for _, s := range strings {
        if s != "" {
            strings[i] = s
            i++
        }
    }
    return strings[:i]  // 返回的是所需要的那部分slice，使用的是同一个底层数组
}
```

这里有一点是输入的`slice`和输出的`slice`拥有相同的底层数组，这样就避免在函数内部重新分配一个数组。当然，这种情况下，底层数组的元素只是部分被修改，示例如下：
```go
data := []string{"one", "", "three"}
fmt.Printf("%q\n", nonempty(data))  // ["one" "three"]
fmt.Printf("%q\n", data)    // ["one" "three" "three"]，这个输出可以很好的看出，共享了一个数组
```
因此，通常我们会这样来写：`data = noempty(data)`

函数`nonempty`还可以利用`append`函数来写：
```go
func nonempty2(strings []string) []string {
    out := strings[:0]  // 引用原始slice的新的零长度的slice
    for _, s := range strings {
        if s != "" {
            out = append(out, s)
        }
    }
    return out
}
```
无论使用哪种方式，重用底层数组的结果是每一个输入值的`slice`最多只有一个输出的结果`slice`，很多从序列中过滤元素再组合结果的算法都是这样做的。这种精细的`slice`使用方式只是一个特例，并不是规则，但是偶尔这样做可以让实现更清晰、高效、有用。

`slice`可以用来实现栈。给定一个空的`slice`元素`stack`，可以使用`append`向`slice`尾部追加值：
```go
stack = append(stack, v)    // push v
```
栈的顶部是最后一个元素：
```go
top := stack[len(stack) - 1]    // 栈顶
```
通过弹出最后一个元素来缩减栈：
```go
stack = stack[:len(stack) - 1]  // pop，这里要注意优先级细节信息
```
为了从`slice`的中间移除一个元素，并保留剩余元素的顺序，可以使用函数`copy`来将高位索引的元素向前移动来覆盖被移除元素所在位置：
```go
// i代表的是索引的位置
func remove(slice []int, i int) []int {
    copy(slice[i:], slice[i+1:])    // 后面的往前面复制
    return slice[:len(slice)-1]
}

func main() {
    s := []int{5, 6, 7, 8, 9}
    fmt.Println(remove(s, 2))   // "[5 6 8 9]"
}
```
如果不需要维持`slice`中剩余元素的顺序，可以简单地将`slice`的最后一个元素赋值给被移除元素所在的索引位置。

## map

散列表是设计精妙、用途广泛的数据结构之一。它是一个拥有键值对元素的无序集合。在这个集合中，键的值是唯一的，键对应的值可以通过键来获取、更新或移除。无论这个散列表有多大，这些操作基本上是通过常量时间的键比较就可以完成。

在Go语言中，`map`是散列表的引用，`map`的类型是`map[K]V`，其中K和V是字典的键和值对应的数据类型。map中所有的键都拥有相同的数据类型，同时所有的值也都拥有相同的数据类型，但是键的类型和值的类型不一定相同。键的类型K必须是可以通过操作符`==`来进行比较的数据类型，所以`map`可以检测某一个键是否已经存在。虽然浮点型是可以比较的，但是比较浮点型的相等性不是一个好主意，尤其是在`NaN`可以是浮点型值的时候。当然，值类型V没有任何限制。

内置函数`make`可以用来创建一个`map`:
```go
ages := make(map[string]int)    // 创建-个从string到int的map
```
也可以使用`map`的字面量来新建一个带初始化键值对元素的字典：
```go
ages := map[string]int{
    "alice":    31,
    "charlie":  34,
}
```
这个等价于：
```go
ages := make(map[string]int)
ages["alice"] = 31
ages["charlie"] = 34
```
因此，新的空`map`的另外一种表达式是：`map[string]int{}`。
`map`的元素访问也是通过下标的方式：
```go
ages["alice"] = 32
fmt.Println(ages["alice"])  // "32"
```
可以使用内置函数`delete`来从字典中根据键移除一个元素：
```go
delete(ages, "alice")   // 通过键移除元素ages["alice"]
```
即使键不在`map`中，上面的操作也都是安全的。`map`使用给定的键来查找元素，如果对应的元素不存在，就返回值类型的零值。例如，下面的代码同样可以工作，尽管bob还不是`map`的键，因为`ages["bob"]`的值是0。
```go
ages["bob"] = ages["bob"] + 1   // 生日快乐
```
快捷赋值方式(如`x += y`和`x++`)对`map`中的元素同样适用，所以上面的代码还可以写成：`ages["bob"]+1`或者更简洁的：`ages["bob"]++`

但是`map`元素不是一个变量，不可以获取它的地址，比如这样是不对的：
```go
_ = &ages["bob"]    // 编译错误，无法获取map元素的地址
```
我们无法获取`map`元素的地址的一个原因是`map`的增长可能会导致已有元素被重新散列到新的存储位置，这样就可能使得获取的地址无效。

可以使用`for`循环（结合`range`关键字）来遍历`map`中所有的键和对应的值，就像上面遍历`slice`一样。循环语句的连续迭代将会使得变量`name`和`age`被赋予`map`中的下一对键和值。
```go
for name,age := range ages {
    fmt.Printf("%s\t%d\n", name, age)
}
```
`map`中元素的迭代顺序是不固定的，不同的实现方法会使用不同的散列算法，得到不同的元素顺序。实践中，我们认为这种顺序是随机的，从一个元素开始到后一个元素，依次执行。这个是有意为之的，这样可以使得程序在不同的散列算法实现下变得健壮。如果需要按照某种顺序来遍历`map`中的元素，我们必须显式地来给键排序。例如，如果键是字符串类型，可以使用`sort`包中的`Strings`函数来进行键的排序，这是一种常见的模式：
```go
import "sort"

var names []string
for name := range ages {
    names = append(names, name)
}
sort.Strings(names)
for _, name := range names {
    fmt.Printf("%s\t%d\n", name, ages[name])
}
```
因为我们一开始就知道`names`的长度，所以直接指定一个`slice`的长度会更加高效。下面的语句创建了一个初始元素为空但是容量足够容纳`ages`中所有键的`slice`:
```go
names := make([]string, 0, len(ages))
```
在上面的第一个循环中，我们只需要`ages`的所有键，所以我们忽略了循环中的第二个变量。在第二个循环中，我们只需要使用`names`中的元素值，所以我们使用空白标识符`_`来忽略第一个变量，即元素索引。

`map`类型的零值是`nil`，也就是说，没有引用任何散列表。
```go
var ages map[string]int
fmt.Println(ages == nil)    // "true"
fmt.Println(len(ages) == 0) // "true"
```
大多数的`map`操作都可以安全地在`map`的零值`nil`上执行，包括查找元素，删除元素，获取`map`元素个数，执行`range`循环，因为这和空`map`的行为一致。但是向零值`map`中设置元素会导致错误：
```go
ages["caro1"] = 21  // 宕机：为零值map中的项赋值，这里就不像CPP的策略了
```
设置元素之前，必须初始化`map`。

通过下标的方式访问`map`中的元素总是会有值。如果键在`map`中，你将得到键对应的值；如果键不在`map`中，你将得到`map`值类型的零值，如同对于`ages["bob"]`的操作结果。很多情况下，这个没有问题，但是有时候你需要知道一个元素是否在`map`中。例如，如果元素类型是数值类型，你需要能够辨别一个不存在的元素或者恰好这个元素的值是0，可以这样做：
```go
age, ok := ages["bob"]
if !ok { /* "bob"不是字典中的键，age == 0 */ }
```
通常这两条语句合并成一条语句，如下所示：
```go
if age, ok := ages["bob"]; !ok { /*...*/ }
```
通过这种下标方式访问`map`中的元素输出两个值，第二个值是一个布尔值，用来报告该元素是否存在。这个布尔变量一般叫作`ok`，尤其是它立即用在`if`条件判断中的时候。

和`slice`一样，`map`不可比较，唯一合法的比较就是和`nil`做比较。为了判断两个`map`是否拥有相同的键和值，必须写一个循环：
```go
func equal(x, y map[string]int) bool {
    if len(x) != len(y) {
        return false
    }
    for k, xv := range x {
        if yv, ok := y[k]; !ok || yv != xv {
            return false
        }
    }
    return true
}
```
注意我们如何使用`!ok`来区分<font color=red>元素不存在</font>和<font color=red>元素存在但值为零</font>的情况。如果我们简单地写成了`xw! = y[k]`,那么下面的调用将错误地报告两个`map`是相等的。
```go
// 如果equal函数写法错误，结果为True，因为不存在的键会自动返回0值
equal(map[string]int{"A": 0}, map[string]int{"B": 42})
```
Go没有提供集合类型，但是既然`map`的键都是唯一的，就可以用`map`来实现这个功能。为了模拟这个功能，程序读取一系列的行，并且只输出每个不同行一次的变体。使用`map`的键来存储这些已经出现过的行，来确保接下来出现的相同行不会输出。
```go
func main() {
    seen := make(map[string]bool)   // 字符串集合
    input := bufio.NewScanner(os.Stdin)
    for input.Scan() {
        line := input.Text()
        if !seen[line] {    // 输出过的一行不会被再次输出
            seen[line] = true
            fmt.Println(line)
        }
    }
    if err := input.Err(); err != nil {
        fmt.Fprintf(os.Stderr, "dedup: %v\n", err)  // 输出错误信息
        os.Exit(1)
    }
}
```
Go程序员通常把这种使用`map`的方式描述成字符串集合，但是请注意，并不是所有的`map[string]bool`都是简单的集合，有一些`map`的值会同时包含`true`和`false`的情况。

有时候，我们需要一个`map`并且需求它的键是`slice`，但是因为`map`的键必须是可以比较的，所以这个功能无法直接实现。然而，我们可以分两步来做。首先，定义一个帮助函数k将每一个键都映射到字符串，当且仅当x和y相等的时候，我们才认为`k(x) == k(y)`。然后，就可以创建一个`map`，`map`的键是字符串类型，在每个键元素被访问的时候，调用这个帮助函数。

下面的例子通过一个字符串列表使用一个`map`来记录`Add`函数被调用的次数。帮助函数使用`fmt.Sprintf`来将一个字符串`slice`转换为一个适合做`map`键的字符串，使用`%q`来格式化`slice`并记录每个字符串的边界。
```go
var m = make(map[string]int)

// 帮助函数k
func k(list []string) string return { fmt.Sprintf("%q", list) }

func Add(list []string) { m[k(1ist)]++ }

func Count(list []string) int { return m[k(list)] }
```
同样的方法适用于任何不可直接比较的键类型，不仅仅局限于`slice`。甚至有的时候，你不想让键通过`==`来比较相等性，而是自定义一种比较方法，例如字符串不区分大小写的比较。同样`k(x)`的类型不一定是字符串类型，任何能够得到想要的比较结果的可比较类型都可以，例如整数、数组或者结构体。

这里还有一个关于`map`的例子，一个统计输入中`Unicode`代码点出现次数的程序。虽然存在着大量可能的字符，但是在一篇文档中仅会有这个巨大字符集的一部分，所以很自然地使用`map`来追踪每个字符出现的次数。

map的值类型可以是复合数据类型，例如`map`或`slice`，如代码所示：
```go
var graph = make(map[string]map[string]bool)    // 键是string类型，值是map类型

// 建立一个从字符串到字符串集合的映射
// form以及to都是string类型
func addEdge(from, to string) {
    edges := graph[from]
    if edges == nil {   // 若键不存在
        edges = make(map[string]bool)
        graph[from] = edges
    }
    edges[to] = true
}
func hasEdge(from, to string) bool {
    return graph[from][to]
}
```
函数`addEdge`演示了一种符合语言习惯的延迟初始化`map`的方法，当`map`中的每个键第一次出现的时候初始化。函数`hasEdge`演示了在`map`中值不存在的情况下，也可以直接使用。即使`from`和`to`都不存在，`graph[from][to]`也始终可以给出一个有意义的值。