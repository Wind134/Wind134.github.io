---
title: Go的复合数据类型
author: Ping
math: true
date: 2024-04-20 11:08:00 +0800
categories: [Go, 语言学习]
tags: [Go]
---

之前讨论了Go程序中的基础数据类型；它们就像宇宙中的原子一样。这部分介绍复合数据类型，复合数据类型是由基本数据类型以各种方式组合而构成的，就像分子由原子构成一样。接下来将重点讲解四种复合数据类型，分别是数组、`slice`、`map`和结构体。

另外末尾部分将演示如何将使用这些数据类型构成的结构化数据编码为JSON数据，从JSON数据转换为结构化数据，以及从模板生成HTML页面。

数组和结构体都是聚合类型，它们的值由内存中的一组变量构成。数组的元素具有相同的类型，而结构体中的元素数据类型则可以不同。数组和结构体的长度都是固定的。反之，`slice`和`map`都是动态数据结构，它们的长度在元素添加到结构中时可以动态增长。

## 数组

数组是具有**固定长度**且拥有零个或者多个相同数据类型元素的序列。由于数组的长度固定，所以在Go里面很少直接使用。`slice`的长度可以增长和缩短，在很多场合下使用得更多。然而，在理解`slice`之前，我们必须先理解数组。

数组中的每个元素是通过索引来访问的，索引从0到数组长度减1。Go内置的函数`len`可以返回数组中的元素个数。
```go
var a [3]int        // 3个整数的数组
fmt.Println(a[0])   // 输出数组的第一个元素
fmt.Print1n(a[len(a)-1])    // 输出数组的最后一个元素，即[2]
// 输出索引和元素
for i,v := range a {
    fmt.Printf("%d %d\n", i, v)
}
// 仅输出元素
for _,v := range a {
    fmt.Printf("%d\n", v)
}
```
默认情况下，一个新数组中的元素初始值为元素类型的零值，对于数字来说，就是0。也可以使用数组字面量根据一组值来初始化一个数组。
```go
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}
fmt.Println(r[2])   // 只有前两位初始化了，未被显式初始化的执行隐式初始化，初始化为"0"
```
在数组字面量中，如果省略号`...`出现在数组长度的位置，那么数组的长度由初始化数组的元素个数决定。以上数组q的定义可以简化为：
```go
q := [..]int{1,2,3}
fmt.Printf("%T\n", q)   // "[3]int"
```
数组的长度是数组类型的一部分，所以`[3]int`和`[4]int`是两种不同的数组类型。数组的长度必须是常量表达式，也就是说，这个表达式的值在程序编译时就可以确定。
```go
q := [3]int{1, 2, 3}
q := [4]int{1, 2, 3, 4} // 编译错误，q已经是一个长度为3的整型数组
```
如我们所见，数组、`slice`、`map`和结构体的字面语法都是相似的。上面的例子是按顺序给出一组值；也可以像这样给出一组值，这一组值同样具有索引和索引对应的值：
```go
type Currency int
const (
    USD Currency = iota
    EUR
    GBP
    RMB
)
symbol := [...]string{USD: "$", EUR: "E", GBP: "E", RMB: "￥"}   // 这里应该是map结构吧，学习到这里的时候是猜测
fmt.Println(RMB,symbol[RMB])    // "3 ￥"
```
在这种情况下，索引可以按照任意顺序出现，并且有的时候还可以省略。和上面一样，没有指定值的索引位置的元素默认被赋予数组元素类型的零值。例如，
```go
r := [...]int{99 : -1}  // 其实就是数组结构，只不过下标表现的形式改变了，这里表示下标99对应的元素为-1
```
定义了一个拥有100个元素的数组`r`，除了最后一个元素值是-1外，该数组中的其他元素值都是0。

如果一个数组的元素类型是可比较的，那么这个数组也是可比较的，这样我们就可以直接使用`==`操作符来比较两个数组，比较的结果是两边元素的值是否完全相同。使用`!=`来比较两个数组是否不同。
```go
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b,a == c, b == c)  // "true false false"
d := [3]int{1, 2}
fmt.Print1n(a == d) // 编译错误：无法比较[2]int == [3]int
```
举一个更有意义的例子，`crypto/sha256`包里面的函数`Sum256`用来为存储在任意字节`slice`中的消息使用SHA256加密散列算法生成一个摘要。摘要信息是256位，即`[32]byte`。如果两个摘要信息相同，那么**很有可能**这两条原始消息就是相同的；如果这两个摘要信息不同，那么这两条原始消息就是不同的。下面的程序输出并比较了`x`和`X`的SHA256散列值：
```go
import "crypto/sha256"

func main() {
    c1 := sha256.Sum256([]byte("x"))
    c2 := sha256.Sum256([]byte("X"))
    fmt.Printf("%x\n%x\n%t\n%T\n", c1, c2, c1 == c2, c1)
// Output:
// 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881
// 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015
// false
// [32]uint8
}
```
原始消息仅有1位(bit)之差，但是它们生成的摘要消息将近一半的位不同，`%x`表示将一个数组或者`slice`里面的字节按照十六进制的方式输出，`%t`表示输出一个布尔值，`%T`表示输出一个值的类型。

当调用一个函数的时候，每个传入的参数都会创建一个副本，然后赋值给对应的函数变量，所以函数接受的是一个副本，而不是原始的参数。使用这种方式传递大的数组会变得很低效，并且在函数内部对数组的任何修改都仅影响副本，而不是原始数组。这种情况下，Go把**数组和其他的类型都看成值传递**。而在其他的语言中，数组是隐式地使用引用传递。

当然，也可以显式地传递一个数组的指针给函数，这样在函数内部对数组的任何修改都会反映到原始数组上面。下面的程序演示如何将一个数组`[32]byte`的元素清零：
```go
func zero(ptr *[32]byte) {
    for i := range ptr {
        ptr[i] = 0
    }
}
```
数组字面量`[32]byte{}`可以生成一个拥有32个字节元素的数组。数组中每个元素的值都是字节类型的零值，即0。可以利用这一点来写另一个版本的数组清零程序：
```go
func zero(ptr *[32]byte) {
    *ptr = [32]byte{}
}
```
使用数组指针是高效的，同时允许被调函数修改调用方数组中的元素，但是因为数组长度是固定的，所以数组本身是不可变的。例如上面的`zero`函数不能接受一个`[16]byte`这样的数组指针，同样，也无法为数组添加或者删除元素。由于数组的长度不可变的特性，除了在特殊的情况下之外，我们很少使用数组。上面关于SHA256的例子中，摘要的结果拥有固定的长度，我们可以使用数组作为函数参数或结果，但是更多的情况下，我们使用`slice`。

## slice

`slice`表示一个拥有相同类型元素的可变长度的序列。`slice`通常写成`[]T`，其中元素的类型都是`T`；它看上去像没有长度的数组类型。

数组和`slice`是紧密关联的。`slice`是一种轻量级的数据结构，可以用来访问数组的部分或者全部的元素，而这个数组称为`slice`的底层数组。`slice`有三个属性：指针、长度和容量。指针指向数组的第一个可以从`slice`中访问的元素，这个元素**并不一定是数组的第一个元素**。长度是指`slice`中的元素个数，它不能超过`slice`的容量。容量的大小通常是从`slice`的起始元素到底层数组的最后一个元素间元素的个数。Go的内置函数`len`和`cap`用来返回`slice`的长度和容量。
- 有点像`vector`；

一个底层数组可以对应多个`slice`，这些`slice`可以引用数组的任何位置，彼此之间的元素还可以重叠。来一个数组声明：
```go
months := [...]string{1: "January", /*...*/, 12: "December"}
```
在这个数组里，January就是`months[1]`，December是`months[12]`。一般来讲，数组中索引0的位置存放数组的第一个元素，但是由于月份总是从1开始，因此我们可以不设置索引为0的元素，这样它的值就是空字符串。

`slice`操作符`s[i:j]`(其中`0 ≤ i ≤ j ≤ cap(s)`)创建了一个新的`slice`，这个新的`slice`引用了序列s中从i到j-1索引位置的所有元素，这里的s既可以是数组或者指向数组的指针，也可以是`slice`。新`slice`的元素个数是`j -i `个。如果上面的表达式中省略了i,那么新`slice`的起始索引位置就是0，即`i = 0`；如果省略了j，那么新`slice`的结束索引位置`1en(s) - 1`，即`j = len(s)`。因此slice对象`months[1:13]`引用了所有的有效月份，同样的写法可以是`months[1:]`。
- 注意：仍然是常规的`[ )`形式，可以理解为一个约定俗称的规则；

slice对象`months[:]`引用了整个数组。接下来，我们定义元素重叠的`slice`，分别用来表示第二季度的月份和北半球的夏季月份：
```go
Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2)     // ["April""May""June"]
fmt.Println(summer) // ["June""July""August"]
```
元素`June`同时包含在两个`slice`中。用下面的代码来输出两个`slice`的共同元素(虽然效率不高)，
```go
    for _, s := range summer {
        for _, q := range Q2 {
            if s ==q {
                fmt.Printf("%s appears in both\n", s)
            }
        }
    }
```
如果`slice`的引用超过了被引用对象的容量，即`cap(s)`，那么会导致程序宕机；但是如果`slice`的引用超出了被引用对象的长度，即`len(s)`，那么最终`slice`会比原`slice`长：
```go
fmt.Println(summer[:20])    // 宕机：超过了被引用对象的边界
endlessSummer := summer[:5] // 在slice容量范围内扩展了s1ice
fmt.Println(endlessSummer)  // "[June July August September October]"
```
另外，注意求字符串(`string`)子串操作和对字节slice(`[]byte`)做slice操作这两者的相似性。它们都写作`x[m:n]`，并且都返回原始字节的一个子序列，同时它们的底层引用方式也是相同的，所以两个操作都消耗常量时间。区别在于：如果x是字符串，那么`x[m:n]`返回的是一个字符串；如果x是字节`slice`，那么返回的结果是字节`slice`。

因为`slice`包含了指向数组元素的指针，所以将一个`slice`传递给函数的时候，可以在函数内部修改底层数组的元素。换言之，创建一个数组的`slice`等于为数组创建了一个别名(见2.3.2节)。下面的函数`reverse`就地反转了整型`slice`中的元素，它适用于任意长度的整型`slice`：
```go
//就地反转一个整型slice中的元素
func reverse(s []int) {
    for i,j := 0, len(s) - 1; 1 < j; i, j = i + 1, j - 1 {
        s[i], s[j] = s[j], s[i] // 交换
    }
}
```
这里，反转整个数组a:
```go
a := [...]int{0, 1, 2, 3, 4, 5}
reverse(a[:])
fmt.Println(a)  // "[5 4 3 2 1 0]"
```
将一个`slice`左移n个元素的简单方法是连续调用`reverse`函数三次。第一次反转前n个元素，第二次反转剩下的元素，最后对整个`slice`再做一次反转(如果将元素右移n个元素，那么先做第三次调用)。
```go
s := []int{0, 1, 2, 3, 4, 5}
// 向左移动两个元素
reverse(s[:2])
reverse(s[2:])
reverse(s)
fmt.Print1n(s)  // "[2 3 4 5 0 1]"
```
注意初始化slice s的表达式和初始化数组a的表达式的区别。`slice`字面量看上去和数组字面量很像，都是用逗号分隔并用花括号括起来的一个元素序列，但是`slice`没有指定长度。这种隐式区别的结果分别是创建有固定长度的数组和创建指向数组的`slice`。和数组一样，`slice`也按照顺序指定元素，也可以通过索引来指定元素，或者两者结合。

和数组不同的是，`slice`无法做比较，因此不能用`==`来测试两个`slice`是否拥有相同的元素。标准库里面提供了高度优化的函数`bytes.Equal`来比较两个字节slice(`[]byte`)。但是对于其他类型的`slice`，我们必须自己写函数来比较。
```go
// 仔细一看，实现逻辑其实极其严格
func equal(x, y []string) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}
```
这种深度比较看上去很简单，并且运行的时候并不比字符串数组使用`==`做比较多耗费时间。你或许奇怪为什么`slice`比较不可以直接使用`==`操作符做比较。这里有两个原因。首先，和数组元素不同，`slice`的元素是非直接的，有可能`slice`可以包含它自身。虽然有办法处理这种特殊的情况，但是没有一种方法是简单、高效、直观的。

其次，因为`slice`的元素不是直接的，所以如果底层数组元素改变，同一个`slice`在不同的时间会拥有不同的元素。由于散列表（例如Go的`map`类型）仅对元素的键做浅拷贝，这就要求散列表里面键在散列表的整个生命周期内必须保持不变。因为`slice`需要深度比较，所以就不能用`slice`作为`map`的键。对于引用类型，例如指针和通道，操作符`==`检查的是引用相等性，即它们是否指向相同的元素。如果有一个相似的`slice`相等性比较功能，它或许会比较有用，也能解决`slice`作为`map`键的问题，但是如果操作符`==`对`slice`和数组的行为不一致，会带来困扰。所以最安全的方法就是不允许直接比较`slice`。

`slice`唯一允许的比较操作是和`nil`做比较，例如：
```go
if summer == nil { /* ... */ }
```
`slice`类型的零值是`nil`。值为`nil`的`slice`没有对应的底层数组。值为`nil`的`slice`长度和容量都是零，但是也有非`nil`的`slice`长度和容量是零，例如`[]int()`或`make([]int, 3)[3:]`。对于任何类型，如果它们的值可以是`nil`，那么这个类型的`nil`值可以使用一种转换表达式，例如`[]int(nil)`。
```go
var s []int     // len(s) == 0, s == nil
s = nil         // len(s) == 0, s == nil
s = []int(nil)  // len(s) == 0, s == nil
s = []int{}     // len(s) == 0, s == nil
```

所以，如果想检查一个`slice`是否是空，那么使用`len(s) == 0`，而不是`s == ni1`，因为`s ！= nil`的情况下，`slice`也有可能是空。除了可以和`nil`做比较之外，值为`nil`的`slice`表现和其他长度为零的`slice`一样。例如，`reverse`函数调用`reverse(nil)`也是安全的。除非文档上面写明了与此相反，否则无论值是否为`nil`，Go的函数都应该以相同的方式对待所有长度为零的`slice`。

内置函数`make`可以创建一个具有指定元素类型、长度和容量的`slice`。其中容量参数可以省略，在这种情况下，`slice`的长度和容量相等。
```go
make([]T, len)
make([]T, len, cap) // 和make([]T, cap)[:len]功能相同
```
深入研究下，其实`make`创建了一个**无名数组**并返回了它的一个`slice`；这个数组仅可以通过这个`slice`来访问。在上面的第一行代码中，所返回的`slice`引用了整个数组。在第二行代码中，slice只引用了数组的前`len`个元素，但是它的容量是数组的长度，这为未来的`slice`元素留出空间。

