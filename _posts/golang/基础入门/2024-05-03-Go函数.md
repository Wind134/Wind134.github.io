---
title: Go函数
author: Ping
math: true
date: 2024-05-03 20:57:00 +0800
categories: [Go, 语言学习]
tags: [Go]
---

函数包含连续的执行语句，可以在代码中通过调用函数来执行它们。函数能够将一个复杂的工作切分成多个更小的模块，使得多人协作变得更加容易。另外，函数对它的使用者隐藏了实现细节。这几方面的特性使函数成为多数编程语言的重要特性之一。

我们之前已经见过许多函数，现在让我们更彻底地探究一下函数。本章的运行示例是一个网络爬虫，它是Web搜索引擎的组件之一，负责抓取网页并分析页面包含的链接，将链接指向的页面也抓取下来，循环往复。利用网络爬虫的实现，我们可以更充分地了解到Go语言的递归、匿名函数、错误处理等方面的函数特性。

## 函数声明

每个函数声明都包含一个名字、一个形参列表、一个可选的返回列表以及函数体：
```plain
func name(parameter-list) (result-list) {
    body
}
```
形参列表指定了一组变量的参数名和参数类型，这些局部变量都由调用者提供的实参传递而来。返回列表则指定了函数返回值的类型。当函数返回一个未命名的返回值或者没有返回值的时候，返回列表的圆括号可以省略。如果一个函数既省略返回列表也没有任何返回值，那么设计这个函数的目的是调用函数之后所带来的附加效果。

在下面的`hypot`函数中：
```go
// x和y是函数声明中的形参，3和4是调用函数时的实参
// 函数返回一个类型为f1oat64的值。
func hypot(x, y float64) float64 {
    return math.Sqrt(x * x + y * y)
}
fmt.Println(hypot(3, 4)) // "5"
```
返回值也可以像形参一样命名。这个时候，每一个命名的返回值会声明为一个局部变量，并根据变量类型初始化为相应的0值。

当函数存在返回列表时，必须显式地以`return`语句结束，除非函数明确不会走完整个执行流程，比如在函数中抛出宕机异常或者函数体内存在一个没有`break`退出条件的无限`for`循环。

在`hypot`函数中使用到一种简写，如果几个形参或者返回值的类型相同，那么类型只需要写一次。以下两个声明是完全相同的：
```go
func f(i, j, k int, s, t string)    { /* ... */ }
func f(i int, j int, k int, s string, t string)    { /* ... */ }
```
下面使用4种方式声明一个带有两个形参和一个返回值的函数，所有变量都是`int`类型。空白标识符用来强调这个形参在函数中未使用。
```go
func add(x int, y int) int  { return x + y }
func sub(x, y int) (z int)  { z = x - y; return }   // 比较新鲜的方式
func first(x int, _ int) int { return x }
func zero(int, int) int  { return 0 }

fmt.Printf("%T\n", add)     // 打印出的类型："func(int, int) int"
fmt.Printf("%T\n", sub)     // "func(int, int) int"
fmt.Printf("%T\n", first)   // "func(int, int) int"
fmt.Printf("%T\n", zero)    // "func(int, int) int"
```
函数的类型称作**函数签名**。当两个函数拥有相同的形参列表和返回列表时，认为这两个**函数的类型或签名**是相同的。而形参和返回值的名字不会影响到函数类型，采用简写同样也不会影响到函数的类型。

每一次调用函数都需要提供实参来对应函数的每一个形参，包括参数的调用顺序也必须一致。Go语言**没有默认参数值的概念也不能指定实参名**，所以除了用于文档说明之外，形参和返回值的命名不会对调用方有任何影响。

形参变量都是函数的局部变量，初始值由调用者提供的实参传递。函数形参以及命名返回值同属于函数最外层作用域的局部变量。

实参是按值传递的，所以函数接收到的是每个实参的副本；修改函数的形参变量并不会影响到调用者提供的实参。然而，如果提供的实参包含引用类型，比如指针、`slice`、`map`、函数或者通道，那么当函数使用形参变量时就有**可能会间接**地修改实参变量。

你可能偶尔会看到**有些函数的声明没有函数体**，那说明这个函数使用除了Go以外的语言实现。这样的声明定义了该函数的签名。
```go
package math
func Sin(x float64) float64 // 使用了汇编语言实现
```

## 递归

函数可以递归调用，这意味着函数可以直接或间接地调用自己。递归是一种实用的技术，可以处理许多带有递归特性的数据结构。在前部分使用递归实现了对一棵树进行插入排序。本节再一次使用递归处理HTML文件。

下面的代码示例使用了一个非标准的包`golang.org/x/net/html`，它提供了解析HTML的功能。`golang.org/x…`下的仓库（比如网络、国际化语言处理、移动平台、图片处理、加密功能以及开发者工具）都由Go团队负责设计和维护。这些包并不属于标准库，原因是它们还在开发当中，或者很少被Go程序员使用。

我们需要的`golang.org/x/net/html`API如下面的代码所示。函数`html.Parse`读入一段字节序列，解析它们，然后返回HTML文档树的根节点`html.Node`。HTML有多种节点，比如文本、注释等。但这里我们只关心表单的元素节点`<name key = 'value'>`。
```go
package html

type Node struct {
    Type    NodeType
    Data    string
    Attr    []Attribute
    FirstChild, Nextsibling *Node
}

type NodeType int32

const (
    ErrorNode NodeType = iota
    TextNode
    DocumentNode
    ElementNode
    CommentNode
    DoctypeNode
)
type Attribute struct {
    Key, Val string
}
func Parse(r io.Reader) (*Node, error)
```

主函数从标准输入中读入HTML，使用递归的`visit`函数获取HTML文本的超链接，并且把所有的超链接输出。
```go
// Findlinks1输出从标准输入中读入的HTML文档中的所有链接
package main
import (
    "fmt"
    "os"
    "golang.org/x/net/html"
)
func main() {
    doc, err := html.Parse(os.Stdin)
    if err != nil {
        fmt.Fprintf(os.Stderr,"findlinks1:%v\n",err)
        os.Exit(1)
    }

    for _, link range visit(nil, doc) {
        fmt.Println(link)
    }
}
```
`visit`函数遍历HTML树上的所有节点，从HTML锚元素`<a href='...'>`中得到`href`属性的内容，将获取到的链接内容添加到字符串`slice`，最后返回这个`slice`:
```go
// visit函数会将n节点中的每个链接添加到结果中
func visit(links []string, n *html.Node) []string {
    if n.Type == html.ElementNode && n.Data == "a" {
        for _, a := range n.Attr {
            if a.Key == "href" {
                links = append(links, a.Val)
            }
        }
    }

    for c := n.FirstChild; c != nil; c = c.NextSibling {
        links = visit(links, c)
    }

    return links
}
```
要对树中的任意节点`n`进行递归，`visit`递归地调用自己去访问节点n的所有子节点，并且将访问过的节点保存在`FirstChild`链表中。

我们在Go的主页运行`findlinks`，使用管道将本书1.5节完成的`fetch`程序的输出定向到`find1inks`。稍稍修改输出，使之更加简洁。