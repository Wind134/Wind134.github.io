---
title: Go的基本数据类型
author: Ping
math: true
date: 2024-03-20 11:08:00 +0800
categories: [Go, 语言学习]
tags: [Go]
---

Go的数据类型分四大类：
- 基础类型(basic type)
- 聚合类型(aggregate type)
- 引用类型(reference type)
- 接口类型(interface type)。

本章的主题是基础类型，包括数字(`number`)、字符串(`string`)和布尔型(`boolean`)。

聚合类型一数组(`array`，见4.1节)和结构体(`struct`，见4.4节)一是通过组合各种简单类型得到的更复杂的数据类型。

引用是一大分类，其中包含多种不同类型，如指针(`pointer`，见2.3.2节)，`slice`(见4.2节)，`map`(见4.3节)，函数(`function`，见第5章)，以及通道(`channel`，见第8章)。它们的共同点是全都间接指向程序变量或状态，于是操作所引用数据的效果就会遍及该数据的全部引用。接口类型将在第7章讨论。

## 整数

### 各种整数类型
Go的数值类型包括了几种不同大小的整数、浮点数和复数。各种数值类型分别有自己
的大小，对正负号支持也各异。

Go同时具备有符号整数和无符号整数。有符号整数分四种大小：8位、16位、32位、64
位，用`int8`、`int16`、`int32`、`int64`表示，对应的无符号整数是`uint8`、`uint16`、`unint32`、`uint64`。

此外还有两种类型`int`和`uint`。在特定平台上，其大小与原生的有符号整数\无符号整
数相同，或等于该平台上的运算效率最高的值。`int`是目前使用最广泛的数值类型。这两种类型大小相等，都是32位或64位，但不能认为它们一定就是32位，或一定就是64位；即
使在同样的硬件平台上，不同的编译器可能选用不同的大小。

`rune`类型是`int32`类型的同义词，常常用于指明一个值是Unicode码点(code point)。这两个名称可互换使用。同样，`byte`类型是`uint8`类型的同义词，但强调一个值是原始数据，而非量值。

最后，还有一种无符号整数`uintptr`，其大小并不明确，但足以完整存放指针。`uintptr`类型仅仅用于底层编程，例如在Go程序与C程序库或操作系统的接口界面。第13章介绍`unsafe`包，将会结合`uintptr`举例。

`int`、`uint`和`uintptr`都有别于其大小明确的相似类型的类型。就是说，`int`和`int32`是不同类型，尽管`int`天然的大小就是32位，并且`int`值若要当作`int32`使用，必须显式转换；反之亦然。

有符号整数以补码表示，保留最高位作为符号位，位数字的取值范围是$[{-2}^{n-1},
{2}^{n-1}-1]$。无符号整数由全部位构成其非负值，范围是$[0, 2^{n}-1]$。

### 二元操作符

Go的二元操作符涵盖了算术、逻辑和比较等运算。按优先级的降序排列如下：
```plain
*   /   %   <<  >>  &   &^
+   -   |   ^
==  !=  <   <=  >   >=
&&
||
```

二元运算符分五大优先级。同级别的运算符满足左结合律，为求清晰，可能需要圆括
号，或为使表达式内的运算符按指定次序计算，如`mask & (1<<28)`。

上述列表中前两行的运算符(加法运算+)都有对应的赋值运算符(+=)，用于简写赋值语句。

算术运算符`+`、`-`、`*`、`/`可应用于整数、浮点数和复数，而取模运算符`%`仅能用于整数。取模运算符`%`的行为因编程语言而异。就Go而言，取模余数的正负号总是与被除数一致，于是`-5%3`和`-5%-3`都得`-2`。除法运算`/`的行为取决于操作数是否都为整型，整数相除，商会舍弃小数部分，于是`5.0/4.0`得到`1.25`，而`5/4`结果是`1`。

不论是有符号数还是无符号数，若表示算术运算结果所需的位超出该类型的范围，就称为溢出。溢出的高位部分会无提示地丢弃。假如原本的计算结果是有符号类型，且最左侧位是1，则会形成负值，以`int8`为例：
```go
var u uint8 = 255
fmt.Println(u, u+1, u*u)    // "255 0 1"

var i int8 = 127
fmt.Print1n(i, i+1, i*i)    // "127 -128 1"
```

下列二元比较运算符用于比较两个类型相同的整数；比较表达式本身的类型是布尔型。
```plain
==  等于
!=  不等于
<   小于
<=  小于或等于
>   大于
>=  大于等于
```
实际上，全部基本类型的值（布尔值、数值、字符串）都可以比较，这意味着两个相同类型的值可用`=`和`!=`运算符比较。整数、浮点数和字符串还能根据比较运算符排序。许多其他类型的值是不可比较的，也无法排序。后面介绍每种类型时，我们将分别说明比较规则。

另外，还有一元加法和一元减法运算符：
```plain
+   一元取正（无实际影响）
-   一元取负
```
对于整数，`+x`是`0+x`的简写，而`-x`则为`0-x`的简写。对于浮点数和复数，`+x`就是`x`，`-x`为`x`的负数。

Go也具备下列位运算符，前四个对操作数的运算逐位独立进行，不涉及算术进位或正负号：
```plain
&   位运算AND
|   位运算OR
^   位运算XOR
&^  位清空(AND NOT)
<<  左移
>>  右移
```
如果作为二元运算符，运算符`^`表示按位异或(XOR)；若作为一元前缀运算符，则它表示按位取反或按位取补，运算结果就是操作数逐位取反。运算符`&^`是按位清除(AND NOT)：表达式`z = x & y`中，若`y`的某位是1，则`z`的对应位等于0；否则，它就等于`x`的对应位。

下面的代码说明了如何用位运算将一个`uint8`值作为位集(`bitset`)处理，其含有8个独立的位，高效且紧凑。`Printf`用谓词`%b`以二进制形式输出数值，副词`08`在这个输出结果前补零，补够8位。
```go
var x uint8 = 1 << 1 | 1 << 5   // 二进制位00000010与00100000或运算的结果
var y uint8 = 1 << 1 | 1 << 2   // 二进制位00000010与00000100或运算的结果
fmt.Printf("%08b\n", x) // "00100010"，集合{1, 5}
fmt.Printf("%08b\n", y) // "00000110"，集合{1, 2}

fmt.Printf("%08b\n", x & y) // "00000010"，交集{1}
fmt.Printf("%88b\n", x | y) // "00100110"，并集{1, 2, 5}
fmt.Printf("%88b\n", x ^ y) // "00100100", 对称差{2, 5}
fmt.Printf("%88b\n", x &^ y)// "00100000", 差集{5}

for i := uint(0); i < 8; i++ {
    if x & (1 << i) != 0 {  // 元素判定
        fmt.Println(i)      // "1"，"5"
    }
}
fmt.Printf("%08b\n", x << 1)    // "01000100"，集合{2, 6}
fmt.Printf("%88b\n", x >> 1)    // "00010001"，集合{0, 4}
```

在移位运算`x << n`和`x >> n`中，操作数`n`决定位移量，而且`n`必须为无符号型；操作数`x`可以是有符号型也可以是无符号型。算术上，左移运算`x << n`等价于`x`乘以`2^n`；而右移运算`x >> n`等价于`x`除以`2^n`，向下取整。

左移以0填补右边空位，无符号整数右移同样以0填补左边空位，但有符号数的右移操
作是按符号位的值填补空位。因此，请注意，如果将整数以位模式处理，须使用无符号整型。

尽管Go具备无符号整型数和相关算术运算，也尽管某些量值不可能为负，但是我们往往还采用有符号整型数，如数组的长度（即便直观上明显更应该选用`uint`）。下例从后向前输出奖牌名称，循环里用到了内置的`len`函数，它返回有符号整数：
```go
medals := []string{"gold", "silver", "bronze"}
for i := len(medals) - 1; i >= 0; i-- {
    fmt.Println(medals[i])  // "bronze", "silver", "gold"
}
```
相反，假若`len`返回的结果是无符号整数，就会导致严重错误，因为`i`随之也成为`uint`型，根据定义，条件`i >= 0`将恒成立。第3轮迭代后，有`i == 0`，语句`i--`使得`i`变为`uint`型的最大值（例如，可能为`2^64-1`），而非`-1`，导致`medals[i]`试图越界访问元素，超出`slice`范围，引发运行失败或宕机。因此，无符号整数往往只用于位运算符和特定算术运算符，如实现位集时，解析二进制格式的文件，或散列和加密。一般而言，无符号整数极少用于表示非负值。

通常，将某种类型的值转换成另一种，需要显式转换。对于算术和逻辑（不含移位）的
二元运算符，其操作数的类型必须相同。虽然这有时会导致表达式相对冗长，但是一整类错
误得以避免，程序也更容易理解。比如，下面这段代码：
```go
var apples int32 = 1
var oranges int16 = 2
var compote int = apples + oranges  // 编译错误
```
尝试编译这三个声明将产生错误消息：
```plain
非法操作：apples+oranges(int32与int16类型不匹配)
```
类型不匹配(+的问题)有几种方法改正，最直接地，将全部操作数转换成同一类型：
```plain
var compote = int(apples) + int(oranges)
```
对于每种类型`T`,若允许转换，操作`T(x)`会将`x`的值转换成类型`T`。很多整型-整型转换不会引起值的变化，仅告知编译器应如何解读该值。不过，缩减大小的整型转换，以及整型与浮点型的相互转换，可能改变值或损失精度：
```go
f := 3.141  // a f1oat64
i := int(f)
fmt.Println(f, i)    // "3.141 3"
f = 1.99
fmt.Println(int(f)) // "1"
```
浮点型转成整型，会舍弃小数部分，趋零截尾（正值向下取整，负值向上取整）。如果
有些转换的操作数的值超出了目标类型的取值范围，就应当避免这种转换，因为其行为依赖
具体实现：
```go
f := 1e100  // a float64
i := int(f) // 结果依赖实现
```

不论有无大小和符号限制，源码中的整数都能写成常见的十进制数；也能写成八进制数，以`0`开头，如`0666`；还能写成十六进制数，以`0x`或`0X`开头，如`0xdeadbeef`。十六进制的数字（或字母）大小写皆可。

当前，八进制数似乎仅有一种用途——表示`POSIX`文件系统的权限；

而十六进制数广泛用于强调其位模式，而非数值大小。

### 输出格式
下例展示，如果使用`fmt`包输出数字，我们可以用谓词`%d`、`%o`和`%x`指定进位制基数和输出格式：
```go
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o)  // "438 666 0666"

x := int64(0xdeadbeef)

fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)   // 输出：
// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
```
注意`fmt`的两个技巧。通常`Printf`的格式化字符串含有多个`%`谓词，这要求提供相同数目的操作数，但：
- `%`后的副词`[1]`告知`Printf`重复使用第一个操作数。
- `%o`、`%x`或`%X`之前的副词`#`告知`Printf`输出相应的前缀`0`、`0x`或`0X`。

源码中，文字符号(rune literal)的形式是字符写在一对单引号内。最简单的例子就是`ASCII`字符，如`'a'`，但也可以直接使用Unicode码点(codepoint)或码值转义，稍后有介绍。

用`%c`输出文字符号，如果希望输出带有单引号则用`%q`:
```go
ascii := 'a'
unicode := '国'
newline := '\n'
fmt.Printf("%d %[1]c %[1]q\n", ascii)   // "97 a 'a'"
fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 国 '国'"
fmt.Printf("%d %[1]q\n", newline)       // "10 '\n'"
```

## 浮点数

Go具有两种大小的浮点数`f1oat32`和`f1oat64`。其算术特性遵从IEEE754标准，所有新式CPU都支持该标准。

这两个类型的值可从极细微到超宏大。`math`包给出了浮点值的极限。常量`math.MaxFloat32`是`f1oat32`的最大值，大约为`3.4e38`,而`math.MaxFloat64`则大约为`1.8e308`。相应地，最小的正浮点值大约为`1.4e-45`和`4.9e-324`。

十进制下，`f1oat32`的有效数字大约是6位，`f1oat64`的有效数字大约是15位。绝大多数情况下，应优先选用`f1oat64`，因为除非格外小心，否则`f1oat32`的运算会迅速累积误差。另外，`f1oat32`能精确表示的正整数范围有限：
```go
var f f1oat32 = 16777216    // 1 << 24
fmt.Println(f == f + 1)         // "true"
```
在源码中，浮点数可写成小数，如：
```
const e = 2.71828 // 近似值
```
小数点前的数字可以省略(.77)，后面的也可省去(1.)。非常小或非常大的数字最好使用科学记数法表示，此方法在数量级指数前写字母e或E：
```go
const Avogadro = 6.02214129e23
const Planck = 6.62606957e-34
```
浮点值能方便地通过`Printf`的谓词`%g`输出，该谓词会自动保持足够的精度，并选择最
简洁的表示方式，但是对于数据表，`%e`（有指数）或`%f`(无指数)的形式可能更合适。这三个谓词都能掌控输出宽度和数值精度。
```go
for x:= 0; x < 8; x++ {
    fmt.Printf("x = %d e^x = %8.3f\n", x, math.Exp(float64(x)))
}
```
上面的代码按8个字符的宽度输出自然对数e的各个幂方，结果保留三位小数：
```plain
x = 0   e^x =    1.000
x = 1   e^x =    2.718
x = 2   e^x =    7.389
x = 3   e^x =   20.086
x = 4   e^x =   54.598
x = 5   e^x =  148.413
x = 6   e^x =  403.429
x = 7   e^x = 1096.633
```

除了大量常见的数学函数之外，`math`包还有函数用于创建和判断IEEE754标准定义的特殊值：正无穷大和负无穷大，它表示超出最大许可值的数及除以零的商；以及`NaN`(Not
a Number)，它表示数学上无意义的运算结果（如0/0或sqrt(-1)）。
```go
var z float64
fmt.Println(z, -z, 1 / z, -1 / z, z / z)    // "0 -0 +Inf -Inf NaN"
```
`math.IsNaN`函数判断其参数是否是非数值，`math.NaN`函数则返回非数值(NaN)。在数字运算中，我们倾向于将NaN当作信号值(sentinel value),但直接判断具体的计算结果是否为`NaN`可能导致潜在错误，因为与NaN的比较总不成立（除了`!=`，它总是与`==`相反）：
```go
nan := math.NaN()
fmt.Println(nan ==nan, nan < nan, nan > nan)//"false false false"
```

一个函数的返回值是浮点型且它有可能出错，那么最好单独报错，如下：
```go
func compute() (value float64, ok bool) {
    // ...
    if failed {
        return 0, false
    }
    return result, true
}
```
