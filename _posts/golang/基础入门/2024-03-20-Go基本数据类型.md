---
title: Go的基本数据类型
author: Ping
math: true
date: 2024-03-20 11:08:00 +0800
categories: [Go, 语言学习]
tags: [Go]
---

Go的数据类型分四大类：
- 基础类型(basic type)
- 聚合类型(aggregate type)
- 引用类型(reference type)
- 接口类型(interface type)。

本章的主题是基础类型，包括数字(`number`)、字符串(`string`)和布尔型(`boolean`)。

聚合类型一数组(`array`，见4.1节)和结构体(`struct`，见4.4节)一是通过组合各种简单类型得到的更复杂的数据类型。

引用是一大分类，其中包含多种不同类型，如指针(`pointer`，见2.3.2节)，`slice`(见4.2节)，`map`(见4.3节)，函数(`function`，见第5章)，以及通道(`channel`，见第8章)。它们的共同点是全都间接指向程序变量或状态，于是操作所引用数据的效果就会遍及该数据的全部引用。接口类型将在第7章讨论。

## 整数

### 各种整数类型
Go的数值类型包括了几种不同大小的整数、浮点数和复数。各种数值类型分别有自己
的大小，对正负号支持也各异。

Go同时具备有符号整数和无符号整数。有符号整数分四种大小：8位、16位、32位、64
位，用`int8`、`int16`、`int32`、`int64`表示，对应的无符号整数是`uint8`、`uint16`、`unint32`、`uint64`。

此外还有两种类型`int`和`uint`。在特定平台上，其大小与原生的有符号整数\无符号整
数相同，或等于该平台上的运算效率最高的值。`int`是目前使用最广泛的数值类型。这两种类型大小相等，都是32位或64位，但不能认为它们一定就是32位，或一定就是64位；即
使在同样的硬件平台上，不同的编译器可能选用不同的大小。

`rune`类型是`int32`类型的同义词，常常用于指明一个值是Unicode码点(code point)。这两个名称可互换使用。同样，`byte`类型是`uint8`类型的同义词，但强调一个值是原始数据，而非量值。

最后，还有一种无符号整数`uintptr`，其大小并不明确，但足以完整存放指针。`uintptr`类型仅仅用于底层编程，例如在Go程序与C程序库或操作系统的接口界面。第13章介绍`unsafe`包，将会结合`uintptr`举例。

`int`、`uint`和`uintptr`都有别于其大小明确的相似类型的类型。就是说，`int`和`int32`是不同类型，尽管`int`天然的大小就是32位，并且`int`值若要当作`int32`使用，必须显式转换；反之亦然。

有符号整数以补码表示，保留最高位作为符号位，位数字的取值范围是$[{-2}^{n-1},
{2}^{n-1}-1]$。无符号整数由全部位构成其非负值，范围是$[0, 2^{n}-1]$。

### 二元操作符

Go的二元操作符涵盖了算术、逻辑和比较等运算。按优先级的降序排列如下：
```plain
*   /   %   <<  >>  &   &^
+   -   |   ^
==  !=  <   <=  >   >=
&&
||
```

二元运算符分五大优先级。同级别的运算符满足左结合律，为求清晰，可能需要圆括
号，或为使表达式内的运算符按指定次序计算，如`mask & (1<<28)`。

上述列表中前两行的运算符(加法运算+)都有对应的赋值运算符(+=)，用于简写赋值语句。

算术运算符`+`、`-`、`*`、`/`可应用于整数、浮点数和复数，而取模运算符`%`仅能用于整数。取模运算符`%`的行为因编程语言而异。就Go而言，取模余数的正负号总是与被除数一致，于是`-5%3`和`-5%-3`都得`-2`。除法运算`/`的行为取决于操作数是否都为整型，整数相除，商会舍弃小数部分，于是`5.0/4.0`得到`1.25`，而`5/4`结果是`1`。

不论是有符号数还是无符号数，若表示算术运算结果所需的位超出该类型的范围，就称为溢出。溢出的高位部分会无提示地丢弃。假如原本的计算结果是有符号类型，且最左侧位是1，则会形成负值，以`int8`为例：
```go
var u uint8 = 255
fmt.Println(u, u+1, u*u)    // "255 0 1"

var i int8 = 127
fmt.Print1n(i, i+1, i*i)    // "127 -128 1"
```

下列二元比较运算符用于比较两个类型相同的整数；比较表达式本身的类型是布尔型。
```plain
==  等于
!=  不等于
<   小于
<=  小于或等于
>   大于
>=  大于等于
```
实际上，全部基本类型的值（布尔值、数值、字符串）都可以比较，这意味着两个相同类型的值可用`=`和`!=`运算符比较。整数、浮点数和字符串还能根据比较运算符排序。许多其他类型的值是不可比较的，也无法排序。后面介绍每种类型时，我们将分别说明比较规则。

另外，还有一元加法和一元减法运算符：
```plain
+   一元取正（无实际影响）
-   一元取负
```
对于整数，`+x`是`0+x`的简写，而`-x`则为`0-x`的简写。对于浮点数和复数，`+x`就是`x`，`-x`为`x`的负数。

Go也具备下列位运算符，前四个对操作数的运算逐位独立进行，不涉及算术进位或正负号：
```plain
&   位运算AND
|   位运算OR
^   位运算XOR
&^  位清空(AND NOT)
<<  左移
>>  右移
```
如果作为二元运算符，运算符`^`表示按位异或(XOR)；若作为一元前缀运算符，则它表示按位取反或按位取补，运算结果就是操作数逐位取反。运算符`&^`是按位清除(AND NOT)：表达式`z = x & y`中，若`y`的某位是1，则`z`的对应位等于0；否则，它就等于`x`的对应位。

下面的代码说明了如何用位运算将一个`uint8`值作为位集(`bitset`)处理，其含有8个独立的位，高效且紧凑。`Printf`用谓词`%b`以二进制形式输出数值，副词`08`在这个输出结果前补零，补够8位。
```go
var x uint8 = 1 << 1 | 1 << 5   // 二进制位00000010与00100000或运算的结果
var y uint8 = 1 << 1 | 1 << 2   // 二进制位00000010与00000100或运算的结果
fmt.Printf("%08b\n", x) // "00100010"，集合{1, 5}
fmt.Printf("%08b\n", y) // "00000110"，集合{1, 2}

fmt.Printf("%08b\n", x & y) // "00000010"，交集{1}
fmt.Printf("%88b\n", x | y) // "00100110"，并集{1, 2, 5}
fmt.Printf("%88b\n", x ^ y) // "00100100", 对称差{2, 5}
fmt.Printf("%88b\n", x &^ y)// "00100000", 差集{5}

for i := uint(0); i < 8; i++ {
    if x & (1 << i) != 0 {  // 元素判定
        fmt.Println(i)      // "1"，"5"
    }
}
fmt.Printf("%08b\n", x << 1)    // "01000100"，集合{2, 6}
fmt.Printf("%88b\n", x >> 1)    // "00010001"，集合{0, 4}
```

在移位运算`x << n`和`x >> n`中，操作数`n`决定位移量，而且`n`必须为无符号型；操作数`x`可以是有符号型也可以是无符号型。算术上，左移运算`x << n`等价于`x`乘以`2^n`；而右移运算`x >> n`等价于`x`除以`2^n`，向下取整。

左移以0填补右边空位，无符号整数右移同样以0填补左边空位，但有符号数的右移操
作是按符号位的值填补空位。因此，请注意，如果将整数以位模式处理，须使用无符号整型。

尽管Go具备无符号整型数和相关算术运算，也尽管某些量值不可能为负，但是我们往往还采用有符号整型数，如数组的长度（即便直观上明显更应该选用`uint`）。下例从后向前输出奖牌名称，循环里用到了内置的`len`函数，它返回有符号整数：
```go
medals := []string{"gold", "silver", "bronze"}
for i := len(medals) - 1; i >= 0; i-- {
    fmt.Println(medals[i])  // "bronze", "silver", "gold"
}
```
相反，假若`len`返回的结果是无符号整数，就会导致严重错误，因为`i`随之也成为`uint`型，根据定义，条件`i >= 0`将恒成立。第3轮迭代后，有`i == 0`，语句`i--`使得`i`变为`uint`型的最大值（例如，可能为`2^64-1`），而非`-1`，导致`medals[i]`试图越界访问元素，超出`slice`范围，引发运行失败或宕机。因此，无符号整数往往只用于位运算符和特定算术运算符，如实现位集时，解析二进制格式的文件，或散列和加密。一般而言，无符号整数极少用于表示非负值。

通常，将某种类型的值转换成另一种，需要显式转换。对于算术和逻辑（不含移位）的
二元运算符，其操作数的类型必须相同。虽然这有时会导致表达式相对冗长，但是一整类错
误得以避免，程序也更容易理解。比如，下面这段代码：
```go
var apples int32 = 1
var oranges int16 = 2
var compote int = apples + oranges  // 编译错误
```
尝试编译这三个声明将产生错误消息：
```plain
非法操作：apples+oranges(int32与int16类型不匹配)
```
类型不匹配(+的问题)有几种方法改正，最直接地，将全部操作数转换成同一类型：
```plain
var compote = int(apples) + int(oranges)
```
对于每种类型`T`,若允许转换，操作`T(x)`会将`x`的值转换成类型`T`。很多整型-整型转换不会引起值的变化，仅告知编译器应如何解读该值。不过，缩减大小的整型转换，以及整型与浮点型的相互转换，可能改变值或损失精度：
```go
f := 3.141  // a f1oat64
i := int(f)
fmt.Println(f, i)    // "3.141 3"
f = 1.99
fmt.Println(int(f)) // "1"
```
浮点型转成整型，会舍弃小数部分，趋零截尾（正值向下取整，负值向上取整）。如果
有些转换的操作数的值超出了目标类型的取值范围，就应当避免这种转换，因为其行为依赖
具体实现：
```go
f := 1e100  // a float64
i := int(f) // 结果依赖实现
```

不论有无大小和符号限制，源码中的整数都能写成常见的十进制数；也能写成八进制数，以`0`开头，如`0666`；还能写成十六进制数，以`0x`或`0X`开头，如`0xdeadbeef`。十六进制的数字（或字母）大小写皆可。

当前，八进制数似乎仅有一种用途——表示`POSIX`文件系统的权限；

而十六进制数广泛用于强调其位模式，而非数值大小。

### 输出格式
下例展示，如果使用`fmt`包输出数字，我们可以用谓词`%d`、`%o`和`%x`指定进位制基数和输出格式：
```go
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o)  // "438 666 0666"

x := int64(0xdeadbeef)

fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)   // 输出：
// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
```
注意`fmt`的两个技巧。通常`Printf`的格式化字符串含有多个`%`谓词，这要求提供相同数目的操作数，但：
- `%`后的副词`[1]`告知`Printf`重复使用第一个操作数。
- `%o`、`%x`或`%X`之前的副词`#`告知`Printf`输出相应的前缀`0`、`0x`或`0X`。

源码中，文字符号(rune literal)的形式是字符写在一对单引号内。最简单的例子就是`ASCII`字符，如`'a'`，但也可以直接使用Unicode码点(codepoint)或码值转义，稍后有介绍。

用`%c`输出文字符号，如果希望输出带有单引号则用`%q`:
```go
ascii := 'a'
unicode := '国'
newline := '\n'
fmt.Printf("%d %[1]c %[1]q\n", ascii)   // "97 a 'a'"
fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 国 '国'"
fmt.Printf("%d %[1]q\n", newline)       // "10 '\n'"
```

## 浮点数

Go具有两种大小的浮点数`f1oat32`和`f1oat64`。其算术特性遵从IEEE754标准，所有新式CPU都支持该标准。

这两个类型的值可从极细微到超宏大。`math`包给出了浮点值的极限。常量`math.MaxFloat32`是`f1oat32`的最大值，大约为`3.4e38`,而`math.MaxFloat64`则大约为`1.8e308`。相应地，最小的正浮点值大约为`1.4e-45`和`4.9e-324`。

十进制下，`f1oat32`的有效数字大约是6位，`f1oat64`的有效数字大约是15位。绝大多数情况下，应优先选用`f1oat64`，因为除非格外小心，否则`f1oat32`的运算会迅速累积误差。另外，`f1oat32`能精确表示的正整数范围有限：
```go
var f f1oat32 = 16777216    // 1 << 24
fmt.Println(f == f + 1)         // "true"
```
在源码中，浮点数可写成小数，如：
```
const e = 2.71828 // 近似值
```
小数点前的数字可以省略(.77)，后面的也可省去(1.)。非常小或非常大的数字最好使用科学记数法表示，此方法在数量级指数前写字母e或E：
```go
const Avogadro = 6.02214129e23
const Planck = 6.62606957e-34
```
浮点值能方便地通过`Printf`的谓词`%g`输出，该谓词会自动保持足够的精度，并选择最
简洁的表示方式，但是对于数据表，`%e`（有指数）或`%f`(无指数)的形式可能更合适。这三个谓词都能掌控输出宽度和数值精度。
```go
for x:= 0; x < 8; x++ {
    fmt.Printf("x = %d e^x = %8.3f\n", x, math.Exp(float64(x)))
}
```
上面的代码按8个字符的宽度输出自然对数e的各个幂方，结果保留三位小数：
```plain
x = 0   e^x =    1.000
x = 1   e^x =    2.718
x = 2   e^x =    7.389
x = 3   e^x =   20.086
x = 4   e^x =   54.598
x = 5   e^x =  148.413
x = 6   e^x =  403.429
x = 7   e^x = 1096.633
```

除了大量常见的数学函数之外，`math`包还有函数用于创建和判断IEEE754标准定义的特殊值：正无穷大和负无穷大，它表示超出最大许可值的数及除以零的商；以及`NaN`(Not
a Number)，它表示数学上无意义的运算结果（如0/0或sqrt(-1)）。
```go
var z float64
fmt.Println(z, -z, 1 / z, -1 / z, z / z)    // "0 -0 +Inf -Inf NaN"
```
`math.IsNaN`函数判断其参数是否是非数值，`math.NaN`函数则返回非数值(NaN)。在数字运算中，我们倾向于将NaN当作信号值(sentinel value),但直接判断具体的计算结果是否为`NaN`可能导致潜在错误，因为与NaN的比较总不成立（除了`!=`，它总是与`==`相反）：
```go
nan := math.NaN()
fmt.Println(nan ==nan, nan < nan, nan > nan)//"false false false"
```

一个函数的返回值是浮点型且它有可能出错，那么最好单独报错，如下：
```go
func compute() (value float64, ok bool) {
    // ...
    if failed {
        return 0, false
    }
    return result, true
}
```

## 复数

Go具备两种大小的复数`complex64`和`complex128`，二者分别由`f1oat32`和`f1oat64`构成。

内置的`complex`函数根据给定的实部和虚部创建复数，而内置的`real`函数和`imag`函数则分别提取复数的实部和虚部：
```go
var x complex128 = complex(1, 2)    // 1 + 2i
var y complex128 = complex(3, 4)    // 3 + 4i
fmt.Println(x * y)  // "(-5 + 10i)"
fmt.Println(real(x*y))  // "-5"
fmt.Println(imag(x*y))  // "10"
```

源码中，如果在浮点数或十进制整数后面紧接着写字母`i`,如`3.141592i`或`2i`,它就变成一个虚数，表示一个实部为`0`的复数：
```go
fmt.Print1n(1i * 1i)    // -1
```

根据常量运算规则，复数常量可以和其他常量相加（整型或浮点型，实数和虚数皆可），这让我们可以自然地写出复数，如`1 + 2i`，或等价地，`2i + 1`。前面`x`和`y`的声明可以简写为：
```go
x := 1 + 2i
y := 3 + 4i
```
可以用`==`或`!=`判断复数是否等值。若两个复数的实部和虚部都相等，则它们相等。`math/cmplx`包提供了复数运算所需的库函数，例如复数的平方根函数和复数的幂函数。
```go
fmt.Println(cmplx.Sqrt(-1)) // "(0 + 1i)"
```

## 布尔值

`bool`型的值或布尔值(boolean)只有两种可能：真(true)和假(false)。`if`和`for`语句里的条件就是布尔值，比较操作符（如`==`和`<`）也能得出布尔值结果。一元操作符(`！`)表示逻辑取反，因此`!true`就是`false`，或者可以说`(!true==false)==true`。比如，考虑到代码风格，布尔表达式`x==true`相对冗长，我们总是简化为`x`。

布尔值可以由运算符`&&`(AND)以及`||`(OR)组合运算，这可能引起短路行为：如果运算符左边的操作数已经能直接确定总体结果，则右边的操作数不会计算在内，所以下面的表达式是安全的：
```go
s != "" && s[0] == 'x'
```
其中，如果作用于空字符串，`s[0]`会触发宕机异常。

因为`&&`较`||`优先级更高（助记窍门：`&&`表示逻辑乘法，`||`表示逻辑加法），所以如下形式的条件无须加圆括号：
```go
if 'a' <= c && c <= 'z'||
    'A' <= c && c <= 'Z' ||
    '0' <= c && c <= '9' {
    // ··ASCII字母或数字
    }
```
布尔值无法隐式转换成数值（如0或1），反之也不行。如下状况下就有必要使用显式`if`:
```go
1 := 0
if b {
    1 = 1
}
```

## 字符串

字符串是不可变的字节序列，它可以包含任意数据，包括0值字节，但主要是人类可读的文本。习惯上，文本字符串被解读成按`UTF-8`编码的Unicode码点（文字符号）序列，稍后将细究相关内容。

内置的`len`函数返回字符串的**字节数**（并非文字符号的数目），下标访问操作`s[i]`则取得第`i`个字符，其中`0 <= i < len(s)`。
```go
s := "hello, world"
fmt.Println(len(s)) // "12"
fmt.Println(s[0], s[7]) // "104 119" ('h' and 'w')
```
试图访问许可范围以外的字节会触发宕机异常：
```go
c := s[len(s)]  // 宕机：下标越界
```
字符串的第`i`个字节不一定就是第`i`个字符，因为非ASCII字符的UTF-8码点需要两个字节或多个字节。

子串生成操作`s[i:j]`产生一个新字符串，内容取自原字符串的字节，下标从`i`(含边界值)开始，直到`j`(不含边界值)。结果的大小是`j-i`个字节。
```go
fmt.Println(s[0:5]) // "hello"
```
再次强调，若下标越界，或者`j`的值小于`i`，将触发宕机异常。

操作数`i`与`j`的默认值分别是`0`（字符串起始位置）和`1en(s)`(字符串终止位置)，若省略`i`或`j`，或两者，则取默认值。
```go
fmt.Println(s[:5])  // "hello"
fmt.Println(s[7:])  // "world"
fmt.Println(s[:])   // "hello, world"
```
加号(+)运算符连接两个字符串而生成一个新字符串：
```go
fmt.Println("goodbye" + s[5:])  // "goodbye, world"
```
字符串可以通过比较运算符做比较，如`==`和`<`；比较运算按字节进行，结果服从本身的字典排序。

尽管肯定可以将新值赋予字符串变量，但是字符串值无法改变：字符串值本身所包含的字节序列永不可变。要在一个字符串后面添加另一个字符串，可以这样编写代码：
```go
s := "left foot"
t := s
s += ", right foot"
```
这并不改变`s`原有的字符串值，只是将+=语句生成的新字符串赋予s。同时，t仍然持
有旧的字符串值。
```go
fmt.Println(s)  // "left foot, right foot"
fmt.Println(t)  // "left foot"
```
因为字符串不可改变，所以字符串内部的数据不允许修改：
```go
s[0] = 'L'  // 编译错误：s[0]无法赋值
```
不可变意味着两个字符串能安全地共用同一段底层内存，使得复制任何长度字符串的开销都低廉。类似地，字符串`s`及其子串（如`s[7:]`）可以安全地共用数据，因此子串生成操作的开销低廉。这两种情况下都没有分配新内存。

### 字符串字面量

字符串的值可以直接写成字符串字面量(string literal)，形式上就是带双引号的字节序列：`"He11o,世界"`，因为Go的源文件总是按UTF-8编码，并且习惯上Go的字符串会按UTF-8解读，所以在源码中我们可以将Unicode码点写入字符串字面量。

在带双引号的字符串字面量中，转义序列以反斜杠(`\`)开始，可以将任意值的字节插入字符串中。下面是一组转义符，表示ASCI控制码，如换行符、回车符和制表符。
```plain
\a "警告"或响铃         \b 退格符
\f 换页符              \n 换行符（指直接跳到下一行的同一位置）
\r 回车符(指返回行首)    \t 制表符
\v 垂直制表符           \' 单引号(仅用于文字字符字面量'\'')
\" 双引号(仅用于"..."字面量内部)
\\ 反斜杠
```

源码中的字符串也可以包含十六进制或八进制的任意字节。十六进制的转义字符写成`\xhh`的形式，`h`是十六进制数字（大小写皆可），且必须是两位。八进制的转义字符写成`\ooo`的形式，必须使用三位八进制数字(0~7)，且不能超过`\377`。这两者都表示单个字节，内容是给定值。后面，我们将看到如何将数值形式的Unicode码点嵌入字符串字面量。

原生的字符串字面量的书写形式是\`...\`，使用**反引号**而不是双引号。原生的字符串字面量内，转义序列不起作用；实质内容与字面写法严格一致，包括反斜杠和换行符，因此，在程序源码中，原生的字符串字面量可以展开多行。唯一的特殊处理是回车符会被删除(换行符会保留)，使得同一字符串在所有平台上的值都相同，包括习惯在文本文件存入换行符的系统。

正则表达式往往含有大量反斜杠，可以方便地写成原生的字符串字面量。原生的字面量也适用于HTML模板、JSON字面量、命令行提示信息，以及需要多行文本表达的场景。
```go
const GoUsage = `Go is a tool for managing Go source code.

Usage:
    go command [arguments]
    `
```

**Unicode编码的介绍**

从前，事情简单明晰，至少，狭隘地看，软件只须处理一个字符集：`ASCII`(美国信息交换标准码)。`ASCII`(或更确切地说，`US-ASCII`)码使用7位表示128个字符：大小写英文字母、数字、各种标点和设备控制符。这对早期的计算机行业已经足够了，但是让世界
上众多使用其他语言的人无法在计算机上使用自己的文书体系。随着互联网的兴起，包含纷
繁语言的数据屡见不鲜。到底怎样才能应付语言的繁杂多样，还能兼顾高效率？

答案是`Unicode`(unicode.org)，它囊括了世界上所有文书体系的全部字符，还有重音符和其他变音符，控制码（如制表符和回车符），以及许多特有文字，对它们各自赋予一个叫`Unicode`码点的标准数字。在Go的术语中，这些字符记号称为文字符号(`rune`)。

`Unicode`第8版定义了超过一百种语言文字的12万个字符的码点。它们在计算机程序和数据中如何表示？天然适合保存单个文字符号的数据类型就是`int32`，为Go所采用；
- 正因如此，`rune`类型作为`int32`类型的别名。

我们可以将文字符号的序列表示成`int32`值序列，这种表示方式称作`UTF-32`或`UCS-4`，每个Unicode码点的编码长度相同，都是32位。这种编码简单划一，可是因为大多数面向计算机的可读文本是ASCII码，每个字符只需8位，也就是1字节，导致了不必要的存储空间消耗。

因此，诞生了新的编码方式：`UTF-8`编码；

`UTF-8`以字节为单位对Unicode码点作变长编码。`UTF-8`是现行的一种Unicode标准，由Go的两位创建者Ken Thompson和Rob Pike发明。每个文字符号用1~4个字节表示，ASCII字符的编码仅占1个字节，而其他常用的文书字符的编码只是2或3个字节。一个文字符号编码的首字节的高位指明了后面还有多少字节。若最高位为0，则标示着它是7位的
ASCII码，其文字符号的编码仅占1字节，这样就与传统的ASCII码一致。若最高几位是110，则文字符号的编码占用2个字节，第二个字节以1开始。更长的编码以此类推。
```plain
Oxxxxxxx                            文字符号0~127   (ASCII)
110xxxxx 10xxxxxx                   128~2047    少于128个未使用的值
1110xxxx 10xxxxxx 10xxxxxx          2048~65535  少于2048个未使用的值
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 65536~0x10ffff  其他未使用的值
```
变长编码的字符串无法按下标直接访问第n个字符，然而有失有得，`UTF-8`换来许多有用的特性。`UTF-8`编码紧凑，兼容ASCII，并且自同步：最多追溯3字节，就能定位一个字
符的起始位置。`UTF-8`还是前缀编码，因此它能从左向右解码而不产生歧义，也无须超前预读。于是查找文字符号仅须搜索它自身的字节，不必考虑前文内容。文字符号的字典字节顺序与Unicode码点顺序一致(Unicode设计如此)，因此按`UTF-8`编码排序自然就是对文字符号排序。`UTF-8`编码本身不会嵌入NUL字节(0值)，这便于某些程序语言用NUL标记字符串结尾。

Go的源文件总是以`UTF-8`编码，同时，需要用Go程序操作的文本字符串也优先采用`UTF-8`编码。`unicode`包具备针对单个文字符号的函数(例如区分字母和数字，转换大小写)，而`unicode/utf8`包则提供了按`UTF-8`编码和解码文字符号的函数。

许多Unicode字符难以直接从键盘输入；有的看起来十分相似几乎无法分辨；有些甚至不可见。Go语言中，字符串字面量的转义让我们得以用码点的值来指明Unicode字符。有两种形式，`\uhhhh`表示16位码点值，`\Uhhhhhhhh`表示32位码点值，其中每个h代表一个
十六进制数字；32位形式的码点值几乎不需要用到。这两种形式都以`UTF-8`编码表示出给定的码点。因此，下面几个字符串字面量都表示长度为6字节的相同串：
```plain
"世界"
"\xe4\xb8\x96\xe7\x95\x8c"
"\u4e16\u754c"
"\U00004e16\U0000754c"
```
后面三行的转义序列用不同形式表示第一行的字符串，但实质上它们的字符串值都一样。

Unicode转义符也能用于文字符号。下列字符是等价的：
```plain
'世'    '\u4e16'    'U80004e16'
```
**码点值小于256的文字符号**可以写成单个十六进制数转义的形式，如`'A'`写成`'\x41'`，而更高的码点值则必须使用`\u`或`\U`转义。这就导致，`'\xe4\xb8\x96'`不是合法的文字符号，虽然这三个字节构成某个有效的`UTF-8`编码码点。

由于`UTF-8`的优良特性，许多字符串操作都无须解码。我们可以直接判断某个字符串是否为另一个的前缀：
```go
func HasPrefix(s, prefix string) bool {
    return len(s) >= len(prefix) && s[:len(prefix)]== prefix
}    
// 或者它是否为另一个字符串的后缀：
func HasSuffix(s, suffix string) bool {
    return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
}

// 或者它是否为另一个的子字符串：
func Contains(s, substr string) bool {
    for i :=0;i < len(s); i++ {
        if HasPrefix(s[i:], substr) {
            return true
        }
    }
    return false
}
```

按`UTF-8`编码的文本的逻辑同样也适用原生字节序列，但其他编码则无法如此。(上面的函数取自`strings`包，其实`Contains`函数的具体实现使用了散列方法让搜索更高效。)

另一方面，如果我们真的要逐个逐个处理Unicode字符，则必须使用其他编码机制。考虑我们的一个字符串，它包含两个东亚字符。该字符串的内存布局在书中已展示。它含有13个字节，而按作`UTF-8`解读，本质是9个码点或文字符号的编码：
```go
import "unicode/utf8"

s := "Hello, 世界"
fmt.Println(len(s)) //"13"
fmt.Println(utf8.RuneCountInString(s))  //"9"个码点
// 我们需要UTF-8解码器来处理这些字符，unicode/utf8包就具备一个：
for i := 0; i < len(s); {
    r, size := utf8.DecodeRuneInString(s[i:])
    fmt.Printf("%d\t%c\n", i, r)
    i += size
}
```
每次`DecodeRuneInString`的调用都返回`r`(文字符号本身)和一个值(表示`r`按UTF-8编码所占用的字节数)。这个值用来更新下标`i`，定位字符串内的下一个文字符号。可是按此方法，我们总是需要使用上例中的循环形式。所幸，Go的`range`循环<font color=red>也适用于字符串，按UTF-8隐式解码</font>。注意，对于**非ASCII文字**符号，下标增量大于1。

```go
// 下面的循环会自动处理不同ASCII编码字符的下标增量
for i,r := range "Hello, 世界" {
    fmt.Printf("%d\t%q\t%d\n", i, r, r)
}
```

之前提到过，文本字符串作为按UTF-8编码的Unicode码点序列解读，很大程度是出于习惯，但为了确保使用`range`循环能正确处理字符串，则必须要求而不仅仅是按照习惯。

如果字符串含有任意二进制数，也就是说，UTF-8数据出错，而我们对它做`range`循环，会发生什么？

每次UTF-8解码器读入一个不合理的字节，无论是显式调用`utf8.DecodeRuneInString`，还是在`range`循环内隐式读取，都会产生一个专门的Unicode字符`'\uFFFD'`替换它，其输出通常是个黑色六角形或类似钻石的形状，里面有个白色问号。如果程序碰到这个文字符号值，通常意味着，生成字符串数据的系统上游部分在处理文本编码方面存在瑕疵。

显示出来的文本与字符串的Unicode码点序列存在着对应关系，`[]rune`则可以将相应的字符串转化为字符串的Unicode码点序列；

如果文字符号非法，将被专门的替换字符所取代，以下代码将展示这个过程：

```go
fmt.Println(string(65))      // 输出字符"A"
fmt.Println(string(0x4eac))  // 输出字符"京"
fmt.Println(string(1234567)) // 无意义字符，也就是上面提及的非法字符

s := "我爱你"
fmt.Printf("% x\n", s) // 十六进制的表现形式
r := []rune(s)
fmt.Printf("%x\n", r) // 输出了码点序列
```

### 字符串操作

字符串分两种类型：
- 首先是字符串类型，包含一个字节数组，创建后一般就无法改变。
- 其次是字节slice，可动态增长；

类比CPP中的字面值常量和string字符串即可；

Go中的4个标准包对字符串操作特别重要：`bytes`、`strings`、`strconv`和`unicode`。
- `strings`包提供了许多函数，用于搜索、替换、比较、修整、切分与连接字符串。
- `bytes`包也有类似的函数，用于操作字节`slice`(`[]byte`类型，其某些属性和字符串相同)。由于字符串不可变，因此按增量方式构建字符串会导致多次内存分配和复制。这种情况下，使用`bytes.Buffer`类型会更高效，范例见后。
- `strconv`包具备的函数主要用于转换布尔值、整数、浮点数为与之对应的字符串形式，或者把字符串转换为布尔值、整数、浮点数，另外还有为字符串添加/去除引号的函数。
- `unicode`包备有判别文字符号值特性的函数，如`IsDigit`、`IsLetter`、`IsUpper`和`IsLower`。每个函数以单个文字符号值作为参数，并返回布尔值。若文字符号值是英文字母，转换函数(如`ToUpper`和`ToLower`)将其转换成指定的大小写。

上面所有函数都遵循Unicode标准对字母数字等的分类原则。`strings`包也有类似的函数，函数名也是`ToUpper`和`ToLower`,它们对原字符串的每个字符做指定变换，生成并返回一个新字符串。

下例中，`basename`函数模仿UNIX shell中的同名实用程序。只要s的前缀看起来像是文件系统路径（各部分由斜杠分隔），该版本的`basename(s)`就将其移除，貌似文件类型的后缀也被移除：
```go
fmt.Println(basename("a/b/c.go"))   //"c"
fmt.Println(basename("c.d.go"))     //"c.d"
fmt.Println(basename("abc"))        //"abc"
```
初版的`basename`独自完成全部工作，并不依赖任何库：

`path`包和`path/filapath`包提供了一组更加普遍适用的函数，用来操作文件路径等具有层次结构的名字。`path`包处理以斜杠`/`分段的路径字符串，不分平台。但它不适合用于处理文件名，却适合其他领域，像URL地址的路径部分。

相反地，`path/filepath`包根据宿主平台(host platform)的规则处理文件名，例如POSIX系统使用`/foo/bar`,而Microsoft Windows系统使用`c:\foo\bar`。

若字符串包含一个字节数组，创建后它就无法改变。相反地，字节slice的元素允许随意修改。
- 字节`slice`是Go中的一种切片(字节)序列，是一种动态长度的数据结构；

字符串可以和字节`slice`相互转换：
```go
s := "abc"
b := []byte(s)  // 这个就是字节slice类型的数据结构
s2 := string(b)
```

概念上，`[]byte(s)`转换操作会分配新的字节数组，拷贝填入s含有的字节，并生成一个`slice`引用，指向整个数组。具备优化功能的编译器在某些情况下可能会避免分配内存和复制内容，但一般而言，复制有必要确保s的字节维持不变(即使b的字节在转换后发生改变)。反之，用`string(b)`将字节`slice`转换成字符串也会产生一份副本，保证`s2`也不可变。

为了避免转换和不必要的内存分配，`bytes`包和`strings`包都预备了许多对应的实用函数(utility function),它们两两相对应。例如，strings包具备下面6个函数：
```go
func Contains(s, substr string) bool
func Count(s, sep string) int
func Fields(s string) []string
func HasPrefix(s, prefix string) bool
func Index(s, sep string) int
func Join(a []string, sep string) string
```

bytes包里面的对应函数为：

```go
func Contains(b, subslice []byte) bool
func Count(s, sep []byte) int
func Fields(s []byte) [][]byte      // []byte类型的数组
func HasPrefix(s, prefix []byte) bool
func Index(s, sep []byte) int
func Join(s [][]byte, sep []byte) []byte
```
唯一的不同是，操作对象由字符串变为字节`slice`。

`bytes`包为高效处理字节`slice`提供了`Buffer`类型。`Buffer`起初为空，其大小随着各种类型数据的写入而增长，如`string`、`byte`和`[]byte`。

