---
title: Go基础知识
author: Ping
date: 2024-03-15 11:08:00 +0800
categories: [Go, 语言学习]
tags: [Go]
---

## 内置名称

GO中函数、变量、常量、类型、语句标签和包的名称遵循一个简单的规则：名称的开头是一个字母(Unicode中的字符即可)或下划线，后面可以跟任意数量的字符、数字和下划线，并区分大小写。

### 内置关键字

GO有25个像`if`和`switch`这样的关键字，只能用在语法允许的地方，它们不能作为名称。
```plain
break       default     func    interface   select
case        defer       go      map         struct
chan        else        goto    package     switch
const       fallthrough if      range       type
continue    for         import  return      var
```

另外，还有三十几个内置的预声明的常量、类型和函数：

```plain
常量：true  false   iota    nil

类型：int   int8    int16   int32   int64
uint    uint8   uint16      uint32  uint64  uintptr
float32 float64 complex128  complex64
bool    byte    rune        string  error

函数：make  len     cap     new     append  copy    close
delete  complex     real    imag    panic   recover
```

## 变量声明与赋值

如果一个实体在函数中声明，它只在函数局部有效。如果声明在函数外，它将对包里面的所有源文件可见。

实体第一个字母的大小写决定其可见性是否跨包。如果名称以大写字母的开头，它是导出的，意味着它对包外是可见和可访问的，可以被自己包之外的其他程序所引用，像`fmt`包中的`Printf`，包名本身总是由小写字母组成。

Go语言中，变量、类型、函数和其他标识符的可见性由其名称前缀决定。有三种可见性级别：
- **包级**：以大写字母开头的标识符对包中的所有文件可见。
- **文件级**：以小写字母开头的标识符仅对当前文件可见。
- **块级**：在花括号`{}`内声明的标识符仅对该块可见。

书中推荐**驼峰式**的命名风格；

针对声明的习惯写法，给出下面几个例子：

```go
s := ""         // 合法，声明并初始化，不需要显式指定s的类型
var s string    // 合法，显式声明类型，但同时也已进行了默认初始化
var s = ""      // 合法，声明变量并初始化，不需要显式指定s的类型
var s string = ""   // 合法，显式声明类型，同时也进行了初始化
```

都是合法的声明和初始化，但是有一个问题我们需要考虑到的是，应该要在何种情况下使用何种方式：

- 第一种方式确实简洁，但为了代码维护性的考虑，会建议仅在函数内部使用；
- 第二种方式就是一个默认的初始化；
- 第三种方式用得少，但当我们声明多个变量时会广泛使用；
- 第四种方式在类型一致的情况下使用就显得冗余了，但是在类型不一致的情况下就比较有用；

一般会建议使用第一第二两种方式，第一种方式是显式声明的方式，告诉我们该变量初始化的必要性，第二种方式则通过隐式初始化告知我们初始化的不必要性；

完整的声明形式：
```plain
var name type = expression
```

类型和表达式部分可以省略一个，但是不能都省略。
- 如果类型省略，它的类型将由初始化表达式决定；
- 如果表达式省略，其初始值对应于类型的零值；
	- 对于数字是0，对于布尔值是`false`，对于字符串是`""`；
	- 对于接口和引用类型(slice、指针、map、通道、函数)是`nil`；
	- 对于一个像数组或结构体这样的复合类型，零值是其所有元素或成员的零值。

零值机制保障所有的变量是良好定义的，Go里面不存在未初始化变量。这种机制简化了代码，并且不需要额外工作就能感知边界条件的行为。

可以声明一个变量列表，并选择使用对应的表达式列表对其初始化。忽略类型允许声明多个不同类型的变量。
```go
var i, j, k int     // int, int, int
var b, f, s true, 2.3, "four"   // bool, float64, string
```

初始值设定可以是字面量值或者任意的表达式。包级别的初始化在main开始之前进行，局部变量初始化和声明一样在函数执行期间进行。

变量可以通过调用返回多个值的函数进行初始化：
```go
varf, err = os.Open(name)   // os.Open返回一个文件和一个错误
```

来一个完整的例子：
```go
package main

import "fmt"

const boilingF 212.0    // 声明常量，包级别声明(不是小写吗)
func main() {
	var f boilingF      // 声明且初始化？且是局部声明
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %g°F or %g°C\n", f, c)
    // 输出：
    // boi1ing point = 212°F or 100°C
}

// var声明
var names []string  // names为一字符串数组
var err error       // error为错误类型
var p Point         // Point为点类型
```

### 短变量声明

在函数中，一种称作短变量声明的可选形式可以用来声明和初始化局部变量。它使用
```plain
name:expression
```
的形式，name的类型由expression的类型决定。

```go
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t = 0.0
```

因其短小、灵活，故而在**局部变量的声明和初始化中**主要使用短声明。`var`声明通常是为那些跟初始化表达式类型不一致的局部变量保留的，或者用于后面才对变量赋值以及变量初始值不重要的情况。

短变量声明最少声明一个新变量，否则，代码编译将无法通过：
```go
in, err := os.Open(infile)
out, err := os.Create(outfile)  // out是一个新变量，所以这里编译不会报错

in, err = os.Create(outfile)    // 如果全是声明过的变量，则需要用赋值写法
```

### 指针声明
Go里面同样存在着指针的概念，类比C语言理解；
```go
x := 1
p := &x     // p是整型指针，指向x
fmt.Println(*p) // "1"
*p = 2      // 等价于x = 2，间接改变值
fmt.Println(x)  // 即可测试
```
每一个聚合类型变量的组成（结构体的成员或数组中的元素）都是变量，所以也有一个地址。

变量有时候使用一个地址化的值。代表变量的表达式，是唯一可以应用取地址操作符`&`的表达式。

指针类型的零值是`nil`。测试`p！=nil`，结果是`true`说明`p`指向一个变量。

指针是可比较的，两个指针当且仅当指向同一个变量或者两者都是ni1的情况下才相等。
```go
var x, y int    // 声明两个整型变量
fmt.Println(&x == &x, &x == &y,&x == nil)   // "true false false"
```

一个与C/CPP比较不同的特点：
- 函数返回局部变量的地址是安全的(涉及Go的逃逸分析)；
    ```go
    var p = f()
    func f() *int {
        v := 1
        return &v
    }
    ```
- 但每次调用函数f都会返回一个不同的值；
    ```go
    fmt.Println(f() == f()) // 输出false
    ```

一个与C/CPP运用比较类似的特点：
- 通过传入指针改变指针所指向的变量的值；
    ```go
    func incr(p *int) int { // 函数还是有返回类型的
        *p++    // 递增
        return *p
    }

    v := 1
    incr(&v)    // v现在等于2了
    fmt.Println(incr(&v))   // 现在变成3了
    ```

Go中的指针在`flag`包中很关键，主要用于指代一些参数的地址，看示例代码：
```go
package main

import (
	"flag"
	"fmt"
	"strings"
)

// 下面两个参数都是指针类型
var n = flag.Bool("n", false, "omit trailing newline") // 设置-n参数，"omit trailing newline"是-help时的提示语，不提供信息默认是false
var sep = flag.String("s", "", "separator")            // 设置-s参数，"separator"同样是-help的提示语，不提供信息时默认是""

func main() {
	flag.Parse()
	fmt.Print(strings.Join(flag.Args(), *sep))
	if !*n { // !*n表示，如果该参数出现，则执行代码块中的内容
		fmt.Println() // 带出一个换行符
	}
}
```

**使用`new`函数创建变量**

这部分类似CPP，看代码：
```go
p := new(int)   // *int类型的p，指向未命名的int变量
fmt.Println(*p) // 输出"0"
*p = 2          // 把未命名的int设置为2
fmt.Print1n(*p) // 输出"2"
```

`new`是函数，而不是关键字，因此可以重定义；

### 变量的生命周期
生命周期指在程序执行过程中变量存在的时间段；

包级别变量的生命周期是整个程序的执行时间。相反，局部变量有一个动态的生命周期：每次执行声明语句时创建一个新的实体，变量一直生存到它变得不可访问，这时它占用的存储空间被回收。函数的参数和返回值也是局部变量，它们在其<font color="red">闭包函数</font>被调用的时候创建。

那么垃圾回收器如何知道一个变量是否应该被回收？说来话长，基本思路是每一个包级别的变量，以及每一个当前执行函数的局部变量，可以作为追溯该变量的路径的源头，通过指针和其他方式的引用可以找到变量。如果变量的路径不存在，那么变量变得不可访问，因此它不会影响任何其他的计算过程。
- <font color=red>说实话，没怎么看懂</font>
- go的编译器会自动判断使用堆上还是栈上的空间，看一段代码：
    ```go
    var global *int
    func f() {
        var x int   // x使用堆空间
        x = 1
        global = &x // 因为已经与全局变量global建立了联系
    }
    
    func g() {
        y := new(int)   // y使用栈空间，纯局部变量
        *y = 1
    }
    ```
- go很强大，但是垃圾回收机制即便高效，那也是以内存的负担为代价的；

### 变量赋值

赋值语句用来更新变量所指的值，它最简单的形式由赋值符`=`，以及符号左边的变量和
右边的表达式组成。
```go
x = 1   // 有名称的变量
*p = true   // 间接变量
person.name ="bob"  // 结构体成员
count[x] = count[x] * scale // 数组或slice或map的元素
```

每一个算术和二进制位操作符有一个对应的赋值操作符，例如，最后的那个语句可以重写成：`count[x] *= scale`，它避免了在表达式中重复变量本身。

数字变量也可以通过`++`和`--`语句进行递增和递减：
```go
v := 1
v++ // 等同于v = v + 1; v 变成 2
v-- // 等同于v = v - 1; v 变成 1
```

**多重赋值**

多重赋值允许几个变量一次性被赋值。在实际更新变量前，右边所有的表达式被推演，当变量同时出现在赋值符两侧的时候这种形式特别有用，例如，当交换两个变量的值时：
```go
x,y = y,x
a[i], a[j] = a[j], a[i]

// 计算两数之间的最大公约数
func gcd(x, y int) int {
    for y != 0 {
        x, y = y, x % y // 优雅写法
    }    
    return x
}

// 计算斐波那契数列
func fib(n int) int {
    x, y := 0, 1
    for i := 0; i < n; i++ {
        x, y = y, x + y
    }
    return x
}
```

从风格上考虑，如果表达式比较复杂，则避免使用多重赋值形式；一系列独立的语句更
易读。

需这类表达式（例如一个有多个返回值的函数调用）产生多个值。当在一个赋值语句中使
用这样的调用时，左边的变量个数需要和函数的返回值一样多。

通常函数使用额外的返回值来指示一些错误情况，例如通过`os.Open`返回的`error`类型，或者一个通常叫`ok`的`bool`类型变量。我们会在后面的章节中看到，这里有三个操作符也有类似的行为。如果`map`查询(参考4.3节)、类型断言(参考7.10节)或者通道接收动作(参考8.4.2节)出现在两个结果的赋值语句中，都会产生一个额外的布尔型结果：
```go
v, ok = m[key]  // map查询
v, ok = x.(T)   // 类型断言
v, ok = <-ch    // 通道接收(<符号)
```

不需要的可以甩给空标识符`_`；


## 循环体与语句

在Go语言中，形如`i++`的递增语句是一种语句，因此形如：

```go
j = i++     // 不合法
++i         // 不合法，Go中仅支持后缀
```

for循环时Go语言中唯一的循环语句，一般的形式：

```plain
for initialization; condition; post {
    // 零个或多个语句
}
```

主要注意的特点就是大括号的位置，不能轻易换行；

- `initialization`代表初始化语句；

  - 必须是一条简单的语句，比如简短的变量声明，一个递增或赋值语句，或者一个函数调用；
- `condition`代表条件语句；
  - 是一个布尔表达式，在每一轮迭代开始前推演，是真则执行循环体；
  - 条件不存在则无尽循环；
- `post`在循环体执行之后被执行；
  - 这部分可以是某条语句，执行后会再进入`condition`部分进行判断；  

下面看这个循环体的例子：

~~~go
for _, arg := range os.Args[1:] {   // range是一个关键字，不是函数
    s += sep + arg
    sep = " "
}
~~~

- 由于在go语言中，不允许存在无用的临时变量，所以针对`range`产生索引的部分，使用了一个下划线`_`去接，其实在Python中也有类似用法；
- 其次是字符串追加的效率问题，示例中总是讲`arg`产生的字符串追加到`s`，而这个过程大致上是追加旧的字符串、空格字符、下一个参数，生成一个新的字符串之后赋给`s`，而旧的字符串则会被例行垃圾回收，这样在有大量数据处理的情况下代价是比较大的，这个时候会建议使用`strings`包中的`Join`函数：`fmt.Println(strings.Join(os.Args[1:], " "))`

### 其他控制流

- `switch case`语句

  ```go
  switch coinflip() { 
      case "heads":   // 命中匹配的选项
          heads++
      case "tails": 
          tails++
      default:    // 没有符合条件的case则命中default
          fmt.Println("landed on edge!")
  }
  ```





