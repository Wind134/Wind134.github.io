---
title: Go基础知识
author: Ping
date: 2024-03-15 11:08:00 +0800
categories: [Go, 语言学习]
tags: [Go]
---

## 内置名称

GO中函数、变量、常量、类型、语句标签和包的名称遵循一个简单的规则：名称的开头是一个字母(Unicode中的字符即可)或下划线，后面可以跟任意数量的字符、数字和下划线，并区分大小写。

### 内置关键字

GO有25个像`if`和`switch`这样的关键字，只能用在语法允许的地方，它们不能作为名称。
```plain
break		default		func	interface	select
case		defer		go		map			struct
chan		else		goto	package		switch
const		fallthrough	if		range		type
continue	for			import	return		var
```

另外，还有三十几个内置的预声明的常量、类型和函数：

```plain
常量：true	false	iota	nil

类型：int	int8	int16	int32	int64
uint	uint8	uint16		uint32	uint64	uintptr
float32	float64	complex128	complex64
bool	byte	rune		string	error

函数：make	len		cap		new		append	copy	close
delete	complex		real	imag	panic	recover
```

## 变量声明

如果一个实体在函数中声明，它只在函数局部有效。如果声明在函数外，它将对包里面的所有源文件可见。

实体第一个字母的大小写决定其可见性是否跨包。如果名称以大写字母的开头，它是导出的，意味着它对包外是可见和可访问的，可以被自己包之外的其他程序所引用，像`fmt`包中的`Printf`，包名本身总是由小写字母组成。

Go语言中，变量、类型、函数和其他标识符的可见性由其名称前缀决定。有三种可见性级别：
- **包级**：以大写字母开头的标识符对包中的所有文件可见。
- **文件级**：以小写字母开头的标识符仅对当前文件可见。
- **块级**：在花括号`{}`内声明的标识符仅对该块可见。

书中推荐**驼峰式**的命名风格；

针对声明的习惯写法，给出下面几个例子：

```go
s := ""         // 合法，声明并初始化，不需要显式指定s的类型
var s string    // 合法，显式声明类型，但同时也已进行了默认初始化
var s = ""      // 合法，声明变量并初始化，不需要显式指定s的类型
var s string = ""	// 合法，显式声明类型，同时也进行了初始化
```

都是合法的声明和初始化，但是有一个问题我们需要考虑到的是，应该要在何种情况下使用何种方式：

- 第一种方式确实简洁，但为了代码维护性的考虑，会建议仅在函数内部使用；
- 第二种方式就是一个默认的初始化；
- 第三种方式用得少，但当我们声明多个变量时会广泛使用；
- 第四种方式在类型一致的情况下使用就显得冗余了，但是在类型不一致的情况下就比较有用；

一般会建议使用第一第二两种方式，第一种方式是显式声明的方式，告诉我们该变量初始化的必要性，第二种方式则通过隐式初始化告知我们初始化的不必要性；

完整的声明形式：
```plain
var name type = expression
```

类型和表达式部分可以省略一个，但是不能都省略。
- 如果类型省略，它的类型将由初始化表达式决定；
- 如果表达式省略，其初始值对应于类型的零值；
	- 对于数字是0，对于布尔值是`false`，对于字符串是`""`；
	- 对于接口和引用类型(slice、指针、map、通道、函数)是`nil`；
	- 对于一个像数组或结构体这样的复合类型，零值是其所有元素或成员的零值。

零值机制保障所有的变量是良好定义的，Go里面不存在未初始化变量。这种机制简化了代码，并且不需要额外工作就能感知边界条件的行为。

可以声明一个变量列表，并选择使用对应的表达式列表对其初始化。忽略类型允许声明多个不同类型的变量。
```go
var i, j, k int		// int, int, int
var b, f, s true, 2.3, "four"	// bool, float64, string
```

初始值设定可以是字面量值或者任意的表达式。包级别的初始化在main开始之前进行，局部变量初始化和声明一样在函数执行期间进行。

变量可以通过调用返回多个值的函数进行初始化：
```go
varf, err = os.Open(name) // os.Open返回一个文件和一个错误
```

来一个完整的例子：
```go
package main

import "fmt"

const boilingF 212.0	// 声明常量，包级别声明(不是小写吗)
func main() {
	var f boilingF		// 声明且初始化？且是局部声明
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %g°F or %g°C\n", f, c)
	// 输出：
	// boi1ing point = 212°F or 100°C
}

// var声明
var names []string	// names为一字符串数组
var err error		// error为错误类型
var p Point			// Point为点类型
```

### 短变量声明

在函数中，一种称作短变量声明的可选形式可以用来声明和初始化局部变量。它使用
```plain
name:expression
```
的形式，name的类型由expression的类型决定。

```go
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t = 0.0
```

因其短小、灵活，故而在**局部变量的声明和初始化中**主要使用短声明。`var`声明通常是为那些跟初始化表达式类型不一致的局部变量保留的，或者用于后面才对变量赋值以及变量初始值不重要的情况。

短变量声明最少声明一个新变量，否则，代码编译将无法通过：
```go
in, err := os.Open(infile)
out, err := os.Create(outfile)	// out是一个新变量，所以这里编译不会报错

in, err = os.Create(outfile)	// 如果全是声明过的变量，则需要用赋值写法
```

## 循环体与语句

在Go语言中，形如`i++`的递增语句是一种语句，因此形如：

```go
j = i++     // 不合法
++i         // 不合法，Go中仅支持后缀
```

for循环时Go语言中唯一的循环语句，一般的形式：

```plain
for initialization; condition; post {
    // 零个或多个语句
}
```

主要注意的特点就是大括号的位置，不能轻易换行；

- `initialization`代表初始化语句；

  - 必须是一条简单的语句，比如简短的变量声明，一个递增或赋值语句，或者一个函数调用；
- `condition`代表条件语句；
  - 是一个布尔表达式，在每一轮迭代开始前推演，是真则执行循环体；
  - 条件不存在则无尽循环；
- `post`在循环体执行之后被执行；
  - 这部分可以是某条语句，执行后会再进入`condition`部分进行判断；  

下面看这个循环体的例子：

~~~go
for _, arg := range os.Args[1:] {	// range是一个关键字，不是函数
    s += sep + arg
    sep = " "
}
~~~

- 由于在go语言中，不允许存在无用的临时变量，所以针对`range`产生索引的部分，使用了一个下划线`_`去接，其实在Python中也有类似用法；
- 其次是字符串追加的效率问题，示例中总是讲`arg`产生的字符串追加到`s`，而这个过程大致上是追加旧的字符串、空格字符、下一个参数，生成一个新的字符串之后赋给`s`，而旧的字符串则会被例行垃圾回收，这样在有大量数据处理的情况下代价是比较大的，这个时候会建议使用`strings`包中的`Join`函数：`fmt.Println(strings.Join(os.Args[1:], " "))`

### 其他控制流

- `switch case`语句

  ```go
  switch coinflip() { 
      case "heads":   // 命中匹配的选项
          heads++
      case "tails": 
          tails++
      default:    // 没有符合条件的case则命中default
          fmt.Println("landed on edge!")   
  ```





