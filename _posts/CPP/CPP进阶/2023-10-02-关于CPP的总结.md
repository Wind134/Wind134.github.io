---
title: 一些总结&经验
author: Ping
date: 2023-10-02 10:34:00 +0800
categories: [CPP, C++_Primer]
tags: [Programming, C++/C, cpp]
---

本文内容是学习C++/C这么久以来的针对一些问题经验汇总，分三个模块陈述，会在后续的学习过程中不断更新(因为还有一些没汇总成文字)；

## 注意事项

1、`char`与`int`之间的类型转换，直接转换是不行的，转换的是字符的ASCII码。
    
- 这个问题应该是比较显然的；

2、**赋值运算的优先级较低**，而赋值语句会经常出现在条件当中。因赋值运算的优先级相对较低，所以通常需要给赋值部分加上括号使其符合我们的原意！

3、除非必须，否则不用递增递减运算符的后置版本！

4、位移时关于符号位如何处理并没有明确的规定，所以强烈建议仅将位运算符用于处理**无符号**类型。

5、强烈建议通过引用形参访问该类型的对象，如果不设计到对象的写操作，或者说无须改变引用形参的值，则尽可能把形参定义成对常量的引用。

6、**不要返回局部对象的引用或指针**，因为函数完成后，它所占用的存储空间也随之被释放掉，因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。

7、所谓运算符优先级，先要理解什么是运算符，以一句代码为例：`auto val = *(vec.begin());`像在这一行代码中，`*`与`.`就是运算符，但是`.`优先级高于`*`，因此需要加上括号，同时我们也可以换种方式处理实现相同的目的`auto val = vec->begin();`(只是举个例子，vec不能用`->`)。

8、如果在函数中我们有返回数组的需求，但因为函数无法返回多个变量，因此我们可以让其返回一个**指向包含多个整数的数组的指针。**

9、放在`main`函数之外的变量属于全局变量，任何函数可以调用，<font color = 'red'>想到之前的一个疑惑，特此记录。</font>

10、一般来说，在类中不建议使用其他成员的名字作为某个成员函数的参数，**同时也不建议隐藏外层作用域中可能被用到的名字**。

11、<font color=red>怎么理解C++中的某些信息在编译时知晓，在运行时知晓？</font>

- 最明显的就是类的继承体系中关于动态绑定的那部分，分为静态类型与动态类型两种情况；
- 静态类型在编译期就知道具体类型，根据相应函数调用相应方法；
- 动态类型，比如说基类的指针或引用，只有在运行时才知道具体调用哪个版本的方法；

**12、在C++中，返回对象的引用而不是对象自身有几个原因：**

- 效率更高，返回对象引用无需产生对象的拷贝，可以避免额外的对象拷贝带来的时间和空间开销；
- 可以对返回的引用执行修改操作，如果返回对象自身，则调用者得到的是一个副本，无法修改原对象；
- <font color=red>还有一个说是为了避免对象切割，这个不是很理解；</font>

**13、在运算符重载这部分，`+=`定义在类内，`+`定义在类外，为什么要这么设计？**

- `+=`并不产生新的对象，它在原对象基础上修改，在类内可以直接操作原对象，返回对象自身的引用；
- 而`+`需要处理两个对象，在类内只能顾到该对象自身，而设计在类外可以实现对多个对象的处理，且构造一个全新的对象返回结果；

**14、在链表练习中遇到的一些指针使用问题，对基础进行进一步加强**

- 给定一个指针`p1`，我再将该指针的值赋值给另一个指针`p2`；
- 更改`p1`的值不会影响`p2`的值，但是如果更改的是指针`p1`指向的内容的值；
- 那`p2`指向的那片空间的内容自然也发生改变了；

**15、main函数处理命令行选项：**

比如我们编译了这么一个程序：`prog`

这个程序会附带一些命令选项，比如我们执行：`prog -d -o ofile data0`

这些命令行通过两个(可选的)形参传递给main函数：`int main(int argc, char *argv[])`

现在上述的这些命令选项我们想要将他们连接成一个字符串(string)，并输出！示例代码：

```c++
#include <iostream>
#include <string>
int main (int argc, char *argv[])
{ 
    std::string str;
    for (auto i = 1; i < argc; ++i)
        str = str + argv[i] + " ";
    std::cout << str << std::endl;
    return 0;
}
```

这样就实现了我们的目的！

16、**在main函数执行前先运行的的函数**

- 使用`gcc`拓展，告知编译器这个函数应当在`main`函数执行之前执行，与此同时也可以告知编译器应当`main`函数执行之后，程序结束之前运行；
- 通过调用全局`static`变量去执行函数；
- 还有一种就是利用`lambda`表达式执行；

17、**学习到的C++ 11新特性**

- 定义了空指针`nullptr`，替代`NULL`(<font color=red>具体原因网上有分析</font>)
- 新增了Lambda表达式；
- 新增了右值引用，这在C++ 11标准以前是不被允许的；
- 新增了泛化的常量表达式-主要是`constexpr`；
- 新增了初始化列表，更好的简洁了语法，其次也统一了初始化语法；
- 新增了类型推导-体现在关键字`auto`上，同时使用`decltype`推导表达式类型，具体规则参考本文笔记；
- 新增了基于范围的`for`循环；
- 新增了委托构造函数，构造函数可以调用另一个来实现代码复用；
- 在类的继承部分增加了`final`和`override`关键字，前者限制继续继承，后者关键字表明这是对虚函数的重写，语义更清晰；
- 增加了显式指定或禁止编译器的默认行为的功能；
- 增加了静态`assertion`，原本只有两种方式来`assert`，一种是`assert`宏，在运行期起作用，一种是预处理指令`#error`，在预处理期起作用，而新增的静态`assertion`可以在编译期就能生效，这样针对模板等工具有更好的处理；
- 增加了智能指针，极大方便了动态空间的管理；
- 增加了正则表达式的匹配，这是一个跨时代的变化；
- 新增了增强的元组`tuple`，相比`pair`可以更好的支持变长参数；
- 新增哈希表，C++11标准以前，`map`、`multimap`、`set`、`multiset`使用红黑树实现，插入和查询的复杂度是`log(n)`；
  - 新标准新增了，或者说额外拓展了四种模板类：`unordered_set`、`unordered_multiset`、`unordered_map`、`unordered_multimap`；

---

## 报错情形

1、<font color=red>提示表达式必须包含指向对象的指针类型</font> 或者 <font color=red>提示`int[int]`用作数组下标类型无效</font>

发现的原因：代码中同时定义了一个int型的变量a，但同时以该变量做了数组名，所以发生了冲突......

2、<font color="red">警告：在有返回值的函数中，控制流程到达函数尾</font>

缺少`return`，主要是在遇到if条件之外没有返回值的情况，所以会报警告。

3、<font color=red>reference to non-static member function must be called</font>

这个问题是指你引用(调用)了非静态函数，但你不是通过类对象来调用的。

问题的来源就是`sort()`函数的第三个谓词参数：

按照常理来说，同一个类的非静态`const`成员函数中能相互调用，而不用通过类对象进行访问，为什么这里不行呢？

问题的原因其实就是函数参数不匹配的问题。因为我们普通的成员函数都有一个隐含的`this`指针，表面上看我们的谓词函数只有两个参数，但实际上它有三个参数(多了一个`this`)，而我们调用`sort()`排序函数的时候只需要用到两个参数进行比较，所以就出现了形参与实参不匹配的情况。

所以，解决办法就是把谓词函数`com()`定义为`static`成员函数，这样就不存在对`this`指针的需求了。

---

## 低级错误

1、是因为在写代码的过程中发现，`printf`在输出时末尾总会带一个百分号`%`，后面加了换行符`\n`发现解决了问题。

2、在C语言中，求幂不能直接用`^`符号，在C语言中这是<font color=red>按位异或</font>运算符。

3、在循环遍历数组或者说字符串的时候，我们要记得要控制索引下标在字符串长度范围内，一定要防止出现越界错误。

4、在定义`vector`变量后，进行初始化之后，如果我们进行`push_back`会直接在初始化变量的后面添加数据，所以尽可能不用多此一举，或者换用下标的形式。