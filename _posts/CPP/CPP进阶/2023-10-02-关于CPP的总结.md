---
title: CPP总结&经验
author: Ping
date: 2023-10-02 10:34:00 +0800
categories: [CPP, C++_Primer]
tags: [Programming, C++/C, cpp]
---

本文内容是学习C++/C这么久以来的针对一些问题经验汇总，分三个模块陈述，会在后续的学习过程中不断更新(因为还有一些没汇总成文字)；

## 注意事项

1、`char`与`int`之间的类型转换，直接转换是不行的，转换的是字符的ASCII码。
    
- 这个问题应该是比较显然的；

2、**赋值运算的优先级较低**，而赋值语句会经常出现在条件当中。因赋值运算的优先级相对较低，所以通常需要给赋值部分加上括号使其符合我们的原意！

3、除非必须，否则不用递增递减运算符的后置版本！

4、位移时关于符号位如何处理并没有明确的规定，所以强烈建议仅将位运算符用于处理**无符号**类型。

5、强烈建议通过引用形参访问该类型的对象，如果不设计到对象的写操作，或者说无须改变引用形参的值，则尽可能把形参定义成对常量的引用。

6、**不要返回局部对象的引用或指针**，因为函数完成后，它所占用的存储空间也随之被释放掉，因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。

7、所谓运算符优先级，先要理解什么是运算符，以一句代码为例：`auto val = *(vec.begin());`像在这一行代码中，`*`与`.`就是运算符，但是`.`优先级高于`*`，因此需要加上括号，同时我们也可以换种方式处理实现相同的目的`auto val = vec->begin();`(只是举个例子，vec不能用`->`)。

8、如果在函数中我们有返回数组的需求，但因为函数无法返回多个变量，因此我们可以让其返回一个**指向包含多个整数的数组的指针。**

9、放在`main`函数之外的变量属于全局变量，任何函数可以调用，<font color = 'red'>想到之前的一个疑惑，特此记录。</font>

10、一般来说，在类中不建议使用其他成员的名字作为某个成员函数的参数，**同时也不建议隐藏外层作用域中可能被用到的名字**。

11、<font color=red>怎么理解C++中的某些信息在编译时知晓，在运行时知晓？</font>

- 最明显的就是类的继承体系中关于动态绑定的那部分，分为静态类型与动态类型两种情况；
- 静态类型在编译期就知道具体类型，根据相应函数调用相应方法；
- 动态类型，比如说基类的指针或引用，只有在运行时才知道具体调用哪个版本的方法；

**12、在C++中，返回对象的引用而不是对象自身有几个原因：**

- 效率更高，返回对象引用无需产生对象的拷贝，可以避免额外的对象拷贝带来的时间和空间开销；
- 可以对返回的引用执行修改操作，如果返回对象自身，则调用者得到的是一个副本，无法修改原对象；
- <font color=red>还有一个说是为了避免对象切割，这个不是很理解；</font>

**13、在运算符重载这部分，`+=`定义在类内，`+`定义在类外，为什么要这么设计？**

- `+=`并不产生新的对象，它在原对象基础上修改，在类内可以直接操作原对象，返回对象自身的引用；
- 而`+`需要处理两个对象，在类内只能顾到该对象自身，而设计在类外可以实现对多个对象的处理，且构造一个全新的对象返回结果；

**14、在链表练习中遇到的一些指针使用问题，对基础进行进一步加强**

- 给定一个指针`p1`，我再将该指针的值赋值给另一个指针`p2`；
- 更改`p1`的值不会影响`p2`的值，但是如果更改的是指针`p1`指向的内容的值；
- 那`p2`指向的那片空间的内容自然也发生改变了；

**15、main函数处理命令行选项：**

比如我们编译了这么一个程序：`prog`

这个程序会附带一些命令选项，比如我们执行：`prog -d -o ofile data0`

这些命令行通过两个(可选的)形参传递给main函数：`int main(int argc, char *argv[])`

现在上述的这些命令选项我们想要将他们连接成一个字符串(string)，并输出！示例代码：

```c++
#include <iostream>
#include <string>
int main (int argc, char *argv[])
{ 
    std::string str;
    for (auto i = 1; i < argc; ++i)
        str = str + argv[i] + " ";
    std::cout << str << std::endl;
    return 0;
}
```

这样就实现了我们的目的！

16、**在main函数执行前先运行的的函数**

- 使用`gcc`拓展，告知编译器这个函数应当在`main`函数执行之前执行，与此同时也可以告知编译器应当`main`函数执行之后，程序结束之前运行；
- 通过调用全局`static`变量去执行函数；
- 还有一种就是利用`lambda`表达式执行；

17、**学习到的C++ 11新特性**

- 定义了空指针`nullptr`，替代`NULL`(<font color=red>具体原因网上有分析</font>)
- 新增了Lambda表达式；
- 新增了右值引用，这在C++ 11标准以前是不被允许的；
- 新增了泛化的常量表达式-主要是`constexpr`；
- 新增了初始化列表，更好的简洁了语法，其次也统一了初始化语法；
- 新增了类型推导-体现在关键字`auto`上，同时使用`decltype`推导表达式类型，具体规则参考本文笔记；
- 新增了基于范围的`for`循环；
- 新增了委托构造函数，构造函数可以调用另一个来实现代码复用；
- 在类的继承部分增加了`final`和`override`关键字，前者限制继续继承，后者关键字表明这是对虚函数的重写，语义更清晰；
- 增加了显式指定或禁止编译器的默认行为的功能；
- 增加了静态`assertion`，原本只有两种方式来`assert`，一种是`assert`宏，在运行期起作用，一种是预处理指令`#error`，在预处理期起作用，而新增的静态`assertion`可以在编译期就能生效，这样针对模板等工具有更好的处理；
- 增加了智能指针，极大方便了动态空间的管理；
- 增加了正则表达式的匹配，这是一个跨时代的变化；
- 新增了增强的元组`tuple`，相比`pair`可以更好的支持变长参数；
- 新增哈希表，C++11标准以前，`map`、`multimap`、`set`、`multiset`使用红黑树实现，插入和查询的复杂度是`log(n)`；
  - 新标准新增了，或者说额外拓展了四种模板类：`unordered_set`、`unordered_multiset`、`unordered_map`、`unordered_multimap`；

---

## 报错情形

1、<font color=red>提示表达式必须包含指向对象的指针类型</font> 或者 <font color=red>提示`int[int]`用作数组下标类型无效</font>

发现的原因：代码中同时定义了一个int型的变量a，但同时以该变量做了数组名，所以发生了冲突......

2、<font color="red">警告：在有返回值的函数中，控制流程到达函数尾</font>

缺少`return`，主要是在遇到if条件之外没有返回值的情况，所以会报警告。

3、<font color=red>reference to non-static member function must be called</font>

这个问题是指你引用(调用)了非静态函数，但你不是通过类对象来调用的。

问题的来源就是`sort()`函数的第三个谓词参数：

按照常理来说，同一个类的非静态`const`成员函数中能相互调用，而不用通过类对象进行访问，为什么这里不行呢？

问题的原因其实就是函数参数不匹配的问题。因为我们普通的成员函数都有一个隐含的`this`指针，表面上看我们的谓词函数只有两个参数，但实际上它有三个参数(多了一个`this`)，而我们调用`sort()`排序函数的时候只需要用到两个参数进行比较，所以就出现了形参与实参不匹配的情况。

所以，解决办法就是把谓词函数`com()`定义为`static`成员函数，这样就不存在对`this`指针的需求了。

---

## 低级错误

1、是因为在写代码的过程中发现，`printf`在输出时末尾总会带一个百分号`%`，后面加了换行符`\n`发现解决了问题。

2、在C语言中，求幂不能直接用`^`符号，在C语言中这是<font color=red>按位异或</font>运算符。

3、在循环遍历数组或者说字符串的时候，我们要记得要控制索引下标在字符串长度范围内，一定要防止出现越界错误。

4、在定义`vector`变量后，进行初始化之后，如果我们进行`push_back`会直接在初始化变量的后面添加数据，所以尽可能不用多此一举，或者换用下标的形式。


## 秋招八股汇总

**动态链接与静态链接**

- 静态链接是将所有的库文件和程序代码在编译时合并为一个单独的可执行文件的过程。程序运行时，操作系统加载并执行这个完整的可执行文件。

  优点：
  
  - 可执行文件独立，不依赖于外部的库文件，可以在没有安装对应库文件的系统上运行。
  - 静态链接可以提供更好的性能，因为所有代码和数据都在同一个文件中，避免了运行时的库加载和链接过程。

  缺点：
  
  - 可执行文件的大小较大，因为包含了所有的库文件代码和数据，导致占用更多的磁盘空间。
  - 静态链接的可执行文件无法共享库所带来的更新和优化。
- 动态链接将程序与所需的库文件分开存储，在动态链接中，编译器只将程序代码与外部库的引用信息包含在可执行文件中，而将实际的库文件保存为独立的动态链接库(DLL或共享对象)，当程序运行时，操作系统会在需要的时候加载这些动态链接库。

  优点：
  - 可执行文件较小，只包含程序代码和对库的引用信息，因此占用较少的磁盘空间。
  - 多个程序可以共享同一个动态链接库，节省内存空间。
  - 动态链接库的更新和优化可以直接影响使用该库的多个程序，无需重新编译整个程序。

  缺点：
  - 程序在运行之前需要确保所需的动态链接库已经安装在系统中，如果库文件缺失或版本不匹配，程序可能无法正常运行。
  - 动态链接可能会引入一些运行时的开销，包括加载和链接库文件的时间。

**静态变量的初始化**

- 在`C语言`中未初始化的静态变量会初始化为0；
- `C语言`中静态变量的初始化发生在任何代码执行之前；
- `CPP`由于引入了对象的构造，因此在未初始化的情况下会调用对象的默认构造函数；
- `CPP`则是当且仅当对象首次用到才进行构造；

**CPP与C语言的内存管理**

*内存分配*
- `new`与`malloc`

  - `new`属于操作符，操作符是一种特殊的语法元素，用于对操作数进行操作或执行特定的操作，而`malloc`为内存分配函数；
  - `new`作为操作符不可以重载，但是`new`相关的函数是可以重载的，而malloc本身不可重载；
  - `new`失败时抛出`bad_alloc`异常，`malloc`在分配失败时返回`NULL`指针；
  - `malloc`大抵上分为以下几个步骤：接收内存块的分配请求、寻找合适的内存块、分配内存块、返回指针；

*内存泄漏*
- 原因

  - 资源未得到合理的释放，一般会伴随着忘记`delete`，或者在继承体系中析构函数未设置为`virtual`，智能指针中的循环引用计数出现问题，从而导致资源释放出现问题；

- 悬空指针和野指针

  - 悬空指针是指指向已释放或无效的内存地址的指针。当使用指针访问已释放的内存或无效的内存时，可能会导致未定义的行为。悬空指针通常是由以下情况引起的：

    - 释放内存后未将指针置空：在使用`delete`释放内存后，如果没有将指针置为`nullptr`，指针仍然保留之前的内存地址，成为悬空指针。
    - 返回局部变量的指针：当函数返回一个指向局部变量的指针时，因为局部变量的生命周期限制在函数的作用域内，在函数结束后，该指针将成为悬空指针。
    - 对象销毁后仍然持有指向其成员的指针：如果对象被销毁，而指向其成员的指针仍然存在，并且尝试访问指针指向的成员，将导致悬空指针。

  - 野指针是指指向未知或未分配的内存地址的指针。野指针通常是由以下情况引起的：
    - 指针未初始化：声明指针但未将其初始化，导致指针的值是未知的，成为野指针。
    - 使用已释放的指针：当使用已释放的指针（如delete或free后的指针）时，该指针成为野指针。
    - 越界访问数组：如果指针超出了数组的边界范围，指向的内存地址是未知或未分配的，也形成了野指针。

*对象分配*

- 如何使得程序只能分配在堆上？

  - 使用<font color=red>工厂模式，</font>设计一个类，禁用其默认构造函数和复制构造函数，且将构造函数设计为私有权限，只允许通过静态成员函数或工厂函数来创建对象。这样，只能通过特定的方式(如静态成员函数或工厂函数)来动态分配对象，而无法在栈上直接声明对象。

**面向对象**

*多态性*

- 底层使用了虚函数表，虚函数表存放的内容在编译期间写入，在构造函数执行之后再初始化，虚函数表指针是存在于对象之内的，因此一般计算大小时要加上这部分内容；
- 一般会通过`override`关键字表明这是对一个虚函数的重写，当然在这种场景下没有该关键字也是可以正常实现重写的功能，但强烈建议写上；

*向上转型和向下转型*

- 向上转型指的是将派生类对象的实际地址用基类指针指向，这是多态性实现的关键环节，而且可以认为是安全的，因为在调用基类指针时我们只可能调用到基类指针中所含有的方法；
- 向下转型则是将基类对象的实际地址用派生类指针指向，这是不安全的，因为我们通过派生类指针调用到基类中并不存在的那个方法时，会报错；
  - 如果是通过`dynamic_cast`进行转换，那么失败时会返回空指针`nullptr`；
  - 如果使用`static_cast`进行向下转型，编译器会执行一种静态转换，而无法在运行时检查类型是否匹配，在这种情况下，会发生未定义的行为，这可能导致程序崩溃、数据损坏或其他不可预测的结果。

